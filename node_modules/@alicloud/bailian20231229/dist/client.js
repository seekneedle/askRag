"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetIndexJobStatusResponseBody = exports.GetIndexJobStatusRequest = exports.DescribeFileResponse = exports.DescribeFileResponseBody = exports.DeletePromptTemplateResponse = exports.DeletePromptTemplateResponseBody = exports.DeleteMemoryNodeResponse = exports.DeleteMemoryNodeResponseBody = exports.DeleteMemoryResponse = exports.DeleteMemoryResponseBody = exports.DeleteIndexDocumentResponse = exports.DeleteIndexDocumentResponseBody = exports.DeleteIndexDocumentShrinkRequest = exports.DeleteIndexDocumentRequest = exports.DeleteIndexResponse = exports.DeleteIndexResponseBody = exports.DeleteIndexRequest = exports.DeleteFileResponse = exports.DeleteFileResponseBody = exports.DeleteCategoryResponse = exports.DeleteCategoryResponseBody = exports.DeleteAgentResponse = exports.DeleteAgentResponseBody = exports.CreatePromptTemplateResponse = exports.CreatePromptTemplateResponseBody = exports.CreatePromptTemplateRequest = exports.CreateMemoryNodeResponse = exports.CreateMemoryNodeResponseBody = exports.CreateMemoryNodeRequest = exports.CreateMemoryResponse = exports.CreateMemoryResponseBody = exports.CreateMemoryRequest = exports.CreateIndexResponse = exports.CreateIndexResponseBody = exports.CreateIndexShrinkRequest = exports.CreateIndexRequest = exports.CreateAndPulishAgentResponse = exports.CreateAndPulishAgentResponseBody = exports.CreateAndPulishAgentShrinkRequest = exports.CreateAndPulishAgentRequest = exports.ApplyFileUploadLeaseResponse = exports.ApplyFileUploadLeaseResponseBody = exports.ApplyFileUploadLeaseRequest = exports.AddFileResponse = exports.AddFileResponseBody = exports.AddFileShrinkRequest = exports.AddFileRequest = exports.AddCategoryResponse = exports.AddCategoryResponseBody = exports.AddCategoryRequest = void 0;
exports.UpdateAndPublishAgentResponseBody = exports.UpdateAndPublishAgentShrinkRequest = exports.UpdateAndPublishAgentRequest = exports.SubmitIndexJobResponse = exports.SubmitIndexJobResponseBody = exports.SubmitIndexJobRequest = exports.SubmitIndexAddDocumentsJobResponse = exports.SubmitIndexAddDocumentsJobResponseBody = exports.SubmitIndexAddDocumentsJobShrinkRequest = exports.SubmitIndexAddDocumentsJobRequest = exports.RetrieveResponse = exports.RetrieveResponseBody = exports.RetrieveShrinkRequest = exports.RetrieveRequest = exports.ListPublishedAgentResponse = exports.ListPublishedAgentResponseBody = exports.ListPublishedAgentRequest = exports.ListPromptTemplatesResponse = exports.ListPromptTemplatesResponseBody = exports.ListPromptTemplatesRequest = exports.ListMemoryNodesResponse = exports.ListMemoryNodesResponseBody = exports.ListMemoryNodesRequest = exports.ListMemoriesResponse = exports.ListMemoriesResponseBody = exports.ListMemoriesRequest = exports.ListIndicesResponse = exports.ListIndicesResponseBody = exports.ListIndicesRequest = exports.ListIndexDocumentsResponse = exports.ListIndexDocumentsResponseBody = exports.ListIndexDocumentsRequest = exports.ListFileResponse = exports.ListFileResponseBody = exports.ListFileRequest = exports.ListChunksResponse = exports.ListChunksResponseBody = exports.ListChunksRequest = exports.ListCategoryResponse = exports.ListCategoryResponseBody = exports.ListCategoryRequest = exports.GetPublishedAgentResponse = exports.GetPublishedAgentResponseBody = exports.GetPromptTemplateResponse = exports.GetPromptTemplateResponseBody = exports.GetMemoryNodeResponse = exports.GetMemoryNodeResponseBody = exports.GetMemoryResponse = exports.GetMemoryResponseBody = exports.GetIndexJobStatusResponse = void 0;
exports.ListFileResponseBodyDataFileList = exports.ListChunksResponseBodyData = exports.ListChunksResponseBodyDataNodes = exports.ListCategoryResponseBodyData = exports.ListCategoryResponseBodyDataCategoryList = exports.GetPublishedAgentResponseBodyData = exports.GetPublishedAgentResponseBodyDataApplicationConfig = exports.GetPublishedAgentResponseBodyDataApplicationConfigWorkFlows = exports.GetPublishedAgentResponseBodyDataApplicationConfigTools = exports.GetPublishedAgentResponseBodyDataApplicationConfigSecurity = exports.GetPublishedAgentResponseBodyDataApplicationConfigRagConfig = exports.GetPublishedAgentResponseBodyDataApplicationConfigParameters = exports.GetPublishedAgentResponseBodyDataApplicationConfigLongTermMemory = exports.GetPublishedAgentResponseBodyDataApplicationConfigHistoryConfig = exports.GetIndexJobStatusResponseBodyData = exports.GetIndexJobStatusResponseBodyDataDocuments = exports.DescribeFileResponseBodyData = exports.DeleteIndexDocumentResponseBodyData = exports.DeleteFileResponseBodyData = exports.DeleteCategoryResponseBodyData = exports.CreateIndexResponseBodyData = exports.CreateIndexRequestMetaExtractColumns = exports.CreateIndexRequestDataSource = exports.CreateIndexRequestColumns = exports.CreateAndPulishAgentRequestApplicationConfig = exports.CreateAndPulishAgentRequestApplicationConfigWorkFlows = exports.CreateAndPulishAgentRequestApplicationConfigTools = exports.CreateAndPulishAgentRequestApplicationConfigSecurityConfig = exports.CreateAndPulishAgentRequestApplicationConfigRagConfig = exports.CreateAndPulishAgentRequestApplicationConfigParameters = exports.CreateAndPulishAgentRequestApplicationConfigLongTermMemory = exports.CreateAndPulishAgentRequestApplicationConfigHistoryConfig = exports.ApplyFileUploadLeaseResponseBodyData = exports.ApplyFileUploadLeaseResponseBodyDataParam = exports.AddFileResponseBodyData = exports.AddCategoryResponseBodyData = exports.UpdatePromptTemplateResponse = exports.UpdatePromptTemplateResponseBody = exports.UpdatePromptTemplateRequest = exports.UpdateMemoryNodeResponse = exports.UpdateMemoryNodeResponseBody = exports.UpdateMemoryNodeRequest = exports.UpdateMemoryResponse = exports.UpdateMemoryResponseBody = exports.UpdateMemoryRequest = exports.UpdateFileTagResponse = exports.UpdateFileTagResponseBody = exports.UpdateFileTagShrinkRequest = exports.UpdateFileTagRequest = exports.UpdateAndPublishAgentResponse = void 0;
exports.UpdateFileTagResponseBodyData = exports.UpdateAndPublishAgentRequestApplicationConfig = exports.UpdateAndPublishAgentRequestApplicationConfigWorkFlows = exports.UpdateAndPublishAgentRequestApplicationConfigTools = exports.UpdateAndPublishAgentRequestApplicationConfigSecurity = exports.UpdateAndPublishAgentRequestApplicationConfigRagConfig = exports.UpdateAndPublishAgentRequestApplicationConfigParameters = exports.UpdateAndPublishAgentRequestApplicationConfigLongTermMemory = exports.UpdateAndPublishAgentRequestApplicationConfigHistoryConfig = exports.SubmitIndexJobResponseBodyData = exports.SubmitIndexAddDocumentsJobResponseBodyData = exports.RetrieveResponseBodyData = exports.RetrieveResponseBodyDataNodes = exports.RetrieveRequestRewrite = exports.RetrieveRequestRerank = exports.ListPublishedAgentResponseBodyData = exports.ListPublishedAgentResponseBodyDataList = exports.ListPublishedAgentResponseBodyDataListApplicationConfig = exports.ListPublishedAgentResponseBodyDataListApplicationConfigWorkFlows = exports.ListPublishedAgentResponseBodyDataListApplicationConfigTools = exports.ListPublishedAgentResponseBodyDataListApplicationConfigSecurity = exports.ListPublishedAgentResponseBodyDataListApplicationConfigRagConfig = exports.ListPublishedAgentResponseBodyDataListApplicationConfigParameters = exports.ListPublishedAgentResponseBodyDataListApplicationConfigLongTermMemory = exports.ListPublishedAgentResponseBodyDataListApplicationConfigHistoryConfig = exports.ListPromptTemplatesResponseBodyPromptTemplates = exports.ListMemoryNodesResponseBodyMemoryNodes = exports.ListMemoriesResponseBodyMemories = exports.ListIndicesResponseBodyData = exports.ListIndicesResponseBodyDataIndices = exports.ListIndexDocumentsResponseBodyData = exports.ListIndexDocumentsResponseBodyDataDocuments = exports.ListFileResponseBodyData = void 0;
// This file is auto-generated, don't edit it
/**
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const endpoint_util_1 = __importDefault(require("@alicloud/endpoint-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class AddCategoryRequest extends $tea.Model {
    static names() {
        return {
            categoryName: 'CategoryName',
            categoryType: 'CategoryType',
            parentCategoryId: 'ParentCategoryId',
        };
    }
    static types() {
        return {
            categoryName: 'string',
            categoryType: 'string',
            parentCategoryId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddCategoryRequest = AddCategoryRequest;
class AddCategoryResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            status: 'Status',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: AddCategoryResponseBodyData,
            message: 'string',
            requestId: 'string',
            status: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddCategoryResponseBody = AddCategoryResponseBody;
class AddCategoryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddCategoryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddCategoryResponse = AddCategoryResponse;
class AddFileRequest extends $tea.Model {
    static names() {
        return {
            categoryId: 'CategoryId',
            leaseId: 'LeaseId',
            parser: 'Parser',
            tags: 'Tags',
        };
    }
    static types() {
        return {
            categoryId: 'string',
            leaseId: 'string',
            parser: 'string',
            tags: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddFileRequest = AddFileRequest;
class AddFileShrinkRequest extends $tea.Model {
    static names() {
        return {
            categoryId: 'CategoryId',
            leaseId: 'LeaseId',
            parser: 'Parser',
            tagsShrink: 'Tags',
        };
    }
    static types() {
        return {
            categoryId: 'string',
            leaseId: 'string',
            parser: 'string',
            tagsShrink: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddFileShrinkRequest = AddFileShrinkRequest;
class AddFileResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            status: 'Status',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: AddFileResponseBodyData,
            message: 'string',
            requestId: 'string',
            status: 'string',
            success: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddFileResponseBody = AddFileResponseBody;
class AddFileResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddFileResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddFileResponse = AddFileResponse;
class ApplyFileUploadLeaseRequest extends $tea.Model {
    static names() {
        return {
            fileName: 'FileName',
            md5: 'Md5',
            sizeInBytes: 'SizeInBytes',
        };
    }
    static types() {
        return {
            fileName: 'string',
            md5: 'string',
            sizeInBytes: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ApplyFileUploadLeaseRequest = ApplyFileUploadLeaseRequest;
class ApplyFileUploadLeaseResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            status: 'Status',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ApplyFileUploadLeaseResponseBodyData,
            message: 'string',
            requestId: 'string',
            status: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ApplyFileUploadLeaseResponseBody = ApplyFileUploadLeaseResponseBody;
class ApplyFileUploadLeaseResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ApplyFileUploadLeaseResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ApplyFileUploadLeaseResponse = ApplyFileUploadLeaseResponse;
class CreateAndPulishAgentRequest extends $tea.Model {
    static names() {
        return {
            applicationConfig: 'applicationConfig',
            instructions: 'instructions',
            modelId: 'modelId',
            name: 'name',
        };
    }
    static types() {
        return {
            applicationConfig: CreateAndPulishAgentRequestApplicationConfig,
            instructions: 'string',
            modelId: 'string',
            name: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAndPulishAgentRequest = CreateAndPulishAgentRequest;
class CreateAndPulishAgentShrinkRequest extends $tea.Model {
    static names() {
        return {
            applicationConfigShrink: 'applicationConfig',
            instructions: 'instructions',
            modelId: 'modelId',
            name: 'name',
        };
    }
    static types() {
        return {
            applicationConfigShrink: 'string',
            instructions: 'string',
            modelId: 'string',
            name: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAndPulishAgentShrinkRequest = CreateAndPulishAgentShrinkRequest;
class CreateAndPulishAgentResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'code',
            data: 'data',
            httpStatusCode: 'httpStatusCode',
            message: 'message',
            requestId: 'requestId',
            success: 'success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'string',
            httpStatusCode: 'number',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAndPulishAgentResponseBody = CreateAndPulishAgentResponseBody;
class CreateAndPulishAgentResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateAndPulishAgentResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAndPulishAgentResponse = CreateAndPulishAgentResponse;
class CreateIndexRequest extends $tea.Model {
    static names() {
        return {
            categoryIds: 'CategoryIds',
            chunkSize: 'ChunkSize',
            columns: 'Columns',
            dataSource: 'DataSource',
            description: 'Description',
            documentIds: 'DocumentIds',
            embeddingModelName: 'EmbeddingModelName',
            name: 'Name',
            overlapSize: 'OverlapSize',
            rerankMinScore: 'RerankMinScore',
            rerankModelName: 'RerankModelName',
            separator: 'Separator',
            sinkInstanceId: 'SinkInstanceId',
            sinkRegion: 'SinkRegion',
            sinkType: 'SinkType',
            sourceType: 'SourceType',
            structureType: 'StructureType',
            metaExtractColumns: 'metaExtractColumns',
        };
    }
    static types() {
        return {
            categoryIds: { 'type': 'array', 'itemType': 'string' },
            chunkSize: 'number',
            columns: { 'type': 'array', 'itemType': CreateIndexRequestColumns },
            dataSource: CreateIndexRequestDataSource,
            description: 'string',
            documentIds: { 'type': 'array', 'itemType': 'string' },
            embeddingModelName: 'string',
            name: 'string',
            overlapSize: 'number',
            rerankMinScore: 'number',
            rerankModelName: 'string',
            separator: 'string',
            sinkInstanceId: 'string',
            sinkRegion: 'string',
            sinkType: 'string',
            sourceType: 'string',
            structureType: 'string',
            metaExtractColumns: { 'type': 'array', 'itemType': CreateIndexRequestMetaExtractColumns },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateIndexRequest = CreateIndexRequest;
class CreateIndexShrinkRequest extends $tea.Model {
    static names() {
        return {
            categoryIdsShrink: 'CategoryIds',
            chunkSize: 'ChunkSize',
            columnsShrink: 'Columns',
            dataSourceShrink: 'DataSource',
            description: 'Description',
            documentIdsShrink: 'DocumentIds',
            embeddingModelName: 'EmbeddingModelName',
            name: 'Name',
            overlapSize: 'OverlapSize',
            rerankMinScore: 'RerankMinScore',
            rerankModelName: 'RerankModelName',
            separator: 'Separator',
            sinkInstanceId: 'SinkInstanceId',
            sinkRegion: 'SinkRegion',
            sinkType: 'SinkType',
            sourceType: 'SourceType',
            structureType: 'StructureType',
            metaExtractColumnsShrink: 'metaExtractColumns',
        };
    }
    static types() {
        return {
            categoryIdsShrink: 'string',
            chunkSize: 'number',
            columnsShrink: 'string',
            dataSourceShrink: 'string',
            description: 'string',
            documentIdsShrink: 'string',
            embeddingModelName: 'string',
            name: 'string',
            overlapSize: 'number',
            rerankMinScore: 'number',
            rerankModelName: 'string',
            separator: 'string',
            sinkInstanceId: 'string',
            sinkRegion: 'string',
            sinkType: 'string',
            sourceType: 'string',
            structureType: 'string',
            metaExtractColumnsShrink: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateIndexShrinkRequest = CreateIndexShrinkRequest;
class CreateIndexResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            status: 'Status',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: CreateIndexResponseBodyData,
            message: 'string',
            requestId: 'string',
            status: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateIndexResponseBody = CreateIndexResponseBody;
class CreateIndexResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateIndexResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateIndexResponse = CreateIndexResponse;
class CreateMemoryRequest extends $tea.Model {
    static names() {
        return {
            description: 'description',
        };
    }
    static types() {
        return {
            description: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateMemoryRequest = CreateMemoryRequest;
class CreateMemoryResponseBody extends $tea.Model {
    static names() {
        return {
            memoryId: 'memoryId',
            requestId: 'requestId',
        };
    }
    static types() {
        return {
            memoryId: 'string',
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateMemoryResponseBody = CreateMemoryResponseBody;
class CreateMemoryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateMemoryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateMemoryResponse = CreateMemoryResponse;
class CreateMemoryNodeRequest extends $tea.Model {
    static names() {
        return {
            content: 'content',
        };
    }
    static types() {
        return {
            content: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateMemoryNodeRequest = CreateMemoryNodeRequest;
class CreateMemoryNodeResponseBody extends $tea.Model {
    static names() {
        return {
            memoryNodeId: 'memoryNodeId',
            requestId: 'requestId',
        };
    }
    static types() {
        return {
            memoryNodeId: 'string',
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateMemoryNodeResponseBody = CreateMemoryNodeResponseBody;
class CreateMemoryNodeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateMemoryNodeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateMemoryNodeResponse = CreateMemoryNodeResponse;
class CreatePromptTemplateRequest extends $tea.Model {
    static names() {
        return {
            content: 'content',
            name: 'name',
        };
    }
    static types() {
        return {
            content: 'string',
            name: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreatePromptTemplateRequest = CreatePromptTemplateRequest;
class CreatePromptTemplateResponseBody extends $tea.Model {
    static names() {
        return {
            promptTemplateId: 'promptTemplateId',
            requestId: 'requestId',
        };
    }
    static types() {
        return {
            promptTemplateId: 'string',
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreatePromptTemplateResponseBody = CreatePromptTemplateResponseBody;
class CreatePromptTemplateResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreatePromptTemplateResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreatePromptTemplateResponse = CreatePromptTemplateResponse;
class DeleteAgentResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'code',
            data: 'data',
            httpStatusCode: 'httpStatusCode',
            message: 'message',
            requestId: 'requestId',
            success: 'success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'string',
            httpStatusCode: 'number',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteAgentResponseBody = DeleteAgentResponseBody;
class DeleteAgentResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteAgentResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteAgentResponse = DeleteAgentResponse;
class DeleteCategoryResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            status: 'Status',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DeleteCategoryResponseBodyData,
            message: 'string',
            requestId: 'string',
            status: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteCategoryResponseBody = DeleteCategoryResponseBody;
class DeleteCategoryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteCategoryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteCategoryResponse = DeleteCategoryResponse;
class DeleteFileResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            status: 'Status',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DeleteFileResponseBodyData,
            message: 'string',
            requestId: 'string',
            status: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteFileResponseBody = DeleteFileResponseBody;
class DeleteFileResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteFileResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteFileResponse = DeleteFileResponse;
class DeleteIndexRequest extends $tea.Model {
    static names() {
        return {
            indexId: 'IndexId',
        };
    }
    static types() {
        return {
            indexId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteIndexRequest = DeleteIndexRequest;
class DeleteIndexResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            message: 'Message',
            requestId: 'RequestId',
            status: 'Status',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            message: 'string',
            requestId: 'string',
            status: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteIndexResponseBody = DeleteIndexResponseBody;
class DeleteIndexResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteIndexResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteIndexResponse = DeleteIndexResponse;
class DeleteIndexDocumentRequest extends $tea.Model {
    static names() {
        return {
            documentIds: 'DocumentIds',
            indexId: 'IndexId',
        };
    }
    static types() {
        return {
            documentIds: { 'type': 'array', 'itemType': 'string' },
            indexId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteIndexDocumentRequest = DeleteIndexDocumentRequest;
class DeleteIndexDocumentShrinkRequest extends $tea.Model {
    static names() {
        return {
            documentIdsShrink: 'DocumentIds',
            indexId: 'IndexId',
        };
    }
    static types() {
        return {
            documentIdsShrink: 'string',
            indexId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteIndexDocumentShrinkRequest = DeleteIndexDocumentShrinkRequest;
class DeleteIndexDocumentResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            status: 'Status',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DeleteIndexDocumentResponseBodyData,
            message: 'string',
            requestId: 'string',
            status: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteIndexDocumentResponseBody = DeleteIndexDocumentResponseBody;
class DeleteIndexDocumentResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteIndexDocumentResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteIndexDocumentResponse = DeleteIndexDocumentResponse;
class DeleteMemoryResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteMemoryResponseBody = DeleteMemoryResponseBody;
class DeleteMemoryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteMemoryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteMemoryResponse = DeleteMemoryResponse;
class DeleteMemoryNodeResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteMemoryNodeResponseBody = DeleteMemoryNodeResponseBody;
class DeleteMemoryNodeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteMemoryNodeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteMemoryNodeResponse = DeleteMemoryNodeResponse;
class DeletePromptTemplateResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeletePromptTemplateResponseBody = DeletePromptTemplateResponseBody;
class DeletePromptTemplateResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeletePromptTemplateResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeletePromptTemplateResponse = DeletePromptTemplateResponse;
class DescribeFileResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            status: 'Status',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: DescribeFileResponseBodyData,
            message: 'string',
            requestId: 'string',
            status: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DescribeFileResponseBody = DescribeFileResponseBody;
class DescribeFileResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeFileResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DescribeFileResponse = DescribeFileResponse;
class GetIndexJobStatusRequest extends $tea.Model {
    static names() {
        return {
            indexId: 'IndexId',
            jobId: 'JobId',
            pageNumber: 'PageNumber',
            pageSize: 'pageSize',
        };
    }
    static types() {
        return {
            indexId: 'string',
            jobId: 'string',
            pageNumber: 'number',
            pageSize: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetIndexJobStatusRequest = GetIndexJobStatusRequest;
class GetIndexJobStatusResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            status: 'Status',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetIndexJobStatusResponseBodyData,
            message: 'string',
            requestId: 'string',
            status: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetIndexJobStatusResponseBody = GetIndexJobStatusResponseBody;
class GetIndexJobStatusResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetIndexJobStatusResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetIndexJobStatusResponse = GetIndexJobStatusResponse;
class GetMemoryResponseBody extends $tea.Model {
    static names() {
        return {
            description: 'description',
            memoryId: 'memoryId',
            requestId: 'requestId',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            description: 'string',
            memoryId: 'string',
            requestId: 'string',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetMemoryResponseBody = GetMemoryResponseBody;
class GetMemoryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetMemoryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetMemoryResponse = GetMemoryResponse;
class GetMemoryNodeResponseBody extends $tea.Model {
    static names() {
        return {
            content: 'content',
            memoryId: 'memoryId',
            memoryNodeId: 'memoryNodeId',
            requestId: 'requestId',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            content: 'string',
            memoryId: 'string',
            memoryNodeId: 'string',
            requestId: 'string',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetMemoryNodeResponseBody = GetMemoryNodeResponseBody;
class GetMemoryNodeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetMemoryNodeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetMemoryNodeResponse = GetMemoryNodeResponse;
class GetPromptTemplateResponseBody extends $tea.Model {
    static names() {
        return {
            content: 'content',
            name: 'name',
            promptTemplateId: 'promptTemplateId',
            requestId: 'requestId',
            variables: 'variables',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            content: 'string',
            name: 'string',
            promptTemplateId: 'string',
            requestId: 'string',
            variables: { 'type': 'array', 'itemType': 'string' },
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPromptTemplateResponseBody = GetPromptTemplateResponseBody;
class GetPromptTemplateResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetPromptTemplateResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPromptTemplateResponse = GetPromptTemplateResponse;
class GetPublishedAgentResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'code',
            data: 'data',
            httpStatusCode: 'httpStatusCode',
            message: 'message',
            requestId: 'requestId',
            success: 'success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: GetPublishedAgentResponseBodyData,
            httpStatusCode: 'number',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPublishedAgentResponseBody = GetPublishedAgentResponseBody;
class GetPublishedAgentResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetPublishedAgentResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPublishedAgentResponse = GetPublishedAgentResponse;
class ListCategoryRequest extends $tea.Model {
    static names() {
        return {
            categoryType: 'CategoryType',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            parentCategoryId: 'ParentCategoryId',
        };
    }
    static types() {
        return {
            categoryType: 'string',
            maxResults: 'number',
            nextToken: 'string',
            parentCategoryId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListCategoryRequest = ListCategoryRequest;
class ListCategoryResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            status: 'Status',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ListCategoryResponseBodyData,
            message: 'string',
            requestId: 'string',
            status: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListCategoryResponseBody = ListCategoryResponseBody;
class ListCategoryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListCategoryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListCategoryResponse = ListCategoryResponse;
class ListChunksRequest extends $tea.Model {
    static names() {
        return {
            fields: 'Fields',
            filed: 'Filed',
            indexId: 'IndexId',
            pageNum: 'PageNum',
            pageSize: 'PageSize',
        };
    }
    static types() {
        return {
            fields: { 'type': 'array', 'itemType': 'string' },
            filed: 'string',
            indexId: 'string',
            pageNum: 'number',
            pageSize: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListChunksRequest = ListChunksRequest;
class ListChunksResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            status: 'Status',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ListChunksResponseBodyData,
            message: 'string',
            requestId: 'string',
            status: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListChunksResponseBody = ListChunksResponseBody;
class ListChunksResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListChunksResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListChunksResponse = ListChunksResponse;
class ListFileRequest extends $tea.Model {
    static names() {
        return {
            categoryId: 'CategoryId',
            fileName: 'FileName',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
        };
    }
    static types() {
        return {
            categoryId: 'string',
            fileName: 'string',
            maxResults: 'number',
            nextToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListFileRequest = ListFileRequest;
class ListFileResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            status: 'Status',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ListFileResponseBodyData,
            message: 'string',
            requestId: 'string',
            status: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListFileResponseBody = ListFileResponseBody;
class ListFileResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListFileResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListFileResponse = ListFileResponse;
class ListIndexDocumentsRequest extends $tea.Model {
    static names() {
        return {
            documentName: 'DocumentName',
            documentStatus: 'DocumentStatus',
            indexId: 'IndexId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
        };
    }
    static types() {
        return {
            documentName: 'string',
            documentStatus: 'string',
            indexId: 'string',
            pageNumber: 'number',
            pageSize: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListIndexDocumentsRequest = ListIndexDocumentsRequest;
class ListIndexDocumentsResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            status: 'Status',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ListIndexDocumentsResponseBodyData,
            message: 'string',
            requestId: 'string',
            status: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListIndexDocumentsResponseBody = ListIndexDocumentsResponseBody;
class ListIndexDocumentsResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListIndexDocumentsResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListIndexDocumentsResponse = ListIndexDocumentsResponse;
class ListIndicesRequest extends $tea.Model {
    static names() {
        return {
            indexName: 'IndexName',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
        };
    }
    static types() {
        return {
            indexName: 'string',
            pageNumber: 'string',
            pageSize: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListIndicesRequest = ListIndicesRequest;
class ListIndicesResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            status: 'Status',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ListIndicesResponseBodyData,
            message: 'string',
            requestId: 'string',
            status: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListIndicesResponseBody = ListIndicesResponseBody;
class ListIndicesResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListIndicesResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListIndicesResponse = ListIndicesResponse;
class ListMemoriesRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListMemoriesRequest = ListMemoriesRequest;
class ListMemoriesResponseBody extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            memories: 'memories',
            nextToken: 'nextToken',
            requestId: 'requestId',
            totalCount: 'totalCount',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            memories: { 'type': 'array', 'itemType': ListMemoriesResponseBodyMemories },
            nextToken: 'string',
            requestId: 'string',
            totalCount: 'number',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListMemoriesResponseBody = ListMemoriesResponseBody;
class ListMemoriesResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListMemoriesResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListMemoriesResponse = ListMemoriesResponse;
class ListMemoryNodesRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListMemoryNodesRequest = ListMemoryNodesRequest;
class ListMemoryNodesResponseBody extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            memoryNodes: 'memoryNodes',
            nextToken: 'nextToken',
            requestId: 'requestId',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            memoryNodes: { 'type': 'array', 'itemType': ListMemoryNodesResponseBodyMemoryNodes },
            nextToken: 'string',
            requestId: 'string',
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListMemoryNodesResponseBody = ListMemoryNodesResponseBody;
class ListMemoryNodesResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListMemoryNodesResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListMemoryNodesResponse = ListMemoryNodesResponse;
class ListPromptTemplatesRequest extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            name: 'name',
            nextToken: 'nextToken',
            type: 'type',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            name: 'string',
            nextToken: 'string',
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListPromptTemplatesRequest = ListPromptTemplatesRequest;
class ListPromptTemplatesResponseBody extends $tea.Model {
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            promptTemplates: 'promptTemplates',
            requestId: 'requestId',
            totalCount: 'totalCount',
            workspaceId: 'workspaceId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            promptTemplates: { 'type': 'array', 'itemType': ListPromptTemplatesResponseBodyPromptTemplates },
            requestId: 'string',
            totalCount: 'number',
            workspaceId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListPromptTemplatesResponseBody = ListPromptTemplatesResponseBody;
class ListPromptTemplatesResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListPromptTemplatesResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListPromptTemplatesResponse = ListPromptTemplatesResponse;
class ListPublishedAgentRequest extends $tea.Model {
    static names() {
        return {
            pageNo: 'pageNo',
            pageSize: 'pageSize',
        };
    }
    static types() {
        return {
            pageNo: 'number',
            pageSize: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListPublishedAgentRequest = ListPublishedAgentRequest;
class ListPublishedAgentResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'code',
            data: 'data',
            httpStatusCode: 'httpStatusCode',
            message: 'message',
            requestId: 'requestId',
            success: 'success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: ListPublishedAgentResponseBodyData,
            httpStatusCode: 'number',
            message: 'string',
            requestId: 'string',
            success: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListPublishedAgentResponseBody = ListPublishedAgentResponseBody;
class ListPublishedAgentResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListPublishedAgentResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListPublishedAgentResponse = ListPublishedAgentResponse;
class RetrieveRequest extends $tea.Model {
    static names() {
        return {
            denseSimilarityTopK: 'DenseSimilarityTopK',
            enableReranking: 'EnableReranking',
            enableRewrite: 'EnableRewrite',
            images: 'Images',
            indexId: 'IndexId',
            query: 'Query',
            rerank: 'Rerank',
            rerankMinScore: 'RerankMinScore',
            rerankTopN: 'RerankTopN',
            rewrite: 'Rewrite',
            saveRetrieverHistory: 'SaveRetrieverHistory',
            searchFilters: 'SearchFilters',
            sparseSimilarityTopK: 'SparseSimilarityTopK',
        };
    }
    static types() {
        return {
            denseSimilarityTopK: 'number',
            enableReranking: 'boolean',
            enableRewrite: 'boolean',
            images: { 'type': 'array', 'itemType': 'string' },
            indexId: 'string',
            query: 'string',
            rerank: { 'type': 'array', 'itemType': RetrieveRequestRerank },
            rerankMinScore: 'number',
            rerankTopN: 'number',
            rewrite: { 'type': 'array', 'itemType': RetrieveRequestRewrite },
            saveRetrieverHistory: 'boolean',
            searchFilters: { 'type': 'array', 'itemType': { 'type': 'map', 'keyType': 'string', 'valueType': 'string' } },
            sparseSimilarityTopK: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveRequest = RetrieveRequest;
class RetrieveShrinkRequest extends $tea.Model {
    static names() {
        return {
            denseSimilarityTopK: 'DenseSimilarityTopK',
            enableReranking: 'EnableReranking',
            enableRewrite: 'EnableRewrite',
            imagesShrink: 'Images',
            indexId: 'IndexId',
            query: 'Query',
            rerankShrink: 'Rerank',
            rerankMinScore: 'RerankMinScore',
            rerankTopN: 'RerankTopN',
            rewriteShrink: 'Rewrite',
            saveRetrieverHistory: 'SaveRetrieverHistory',
            searchFiltersShrink: 'SearchFilters',
            sparseSimilarityTopK: 'SparseSimilarityTopK',
        };
    }
    static types() {
        return {
            denseSimilarityTopK: 'number',
            enableReranking: 'boolean',
            enableRewrite: 'boolean',
            imagesShrink: 'string',
            indexId: 'string',
            query: 'string',
            rerankShrink: 'string',
            rerankMinScore: 'number',
            rerankTopN: 'number',
            rewriteShrink: 'string',
            saveRetrieverHistory: 'boolean',
            searchFiltersShrink: 'string',
            sparseSimilarityTopK: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveShrinkRequest = RetrieveShrinkRequest;
class RetrieveResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            status: 'Status',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: RetrieveResponseBodyData,
            message: 'string',
            requestId: 'string',
            status: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveResponseBody = RetrieveResponseBody;
class RetrieveResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RetrieveResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveResponse = RetrieveResponse;
class SubmitIndexAddDocumentsJobRequest extends $tea.Model {
    static names() {
        return {
            categoryIds: 'CategoryIds',
            documentIds: 'DocumentIds',
            indexId: 'IndexId',
            sourceType: 'SourceType',
        };
    }
    static types() {
        return {
            categoryIds: { 'type': 'array', 'itemType': 'string' },
            documentIds: { 'type': 'array', 'itemType': 'string' },
            indexId: 'string',
            sourceType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SubmitIndexAddDocumentsJobRequest = SubmitIndexAddDocumentsJobRequest;
class SubmitIndexAddDocumentsJobShrinkRequest extends $tea.Model {
    static names() {
        return {
            categoryIdsShrink: 'CategoryIds',
            documentIdsShrink: 'DocumentIds',
            indexId: 'IndexId',
            sourceType: 'SourceType',
        };
    }
    static types() {
        return {
            categoryIdsShrink: 'string',
            documentIdsShrink: 'string',
            indexId: 'string',
            sourceType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SubmitIndexAddDocumentsJobShrinkRequest = SubmitIndexAddDocumentsJobShrinkRequest;
class SubmitIndexAddDocumentsJobResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            status: 'Status',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: SubmitIndexAddDocumentsJobResponseBodyData,
            message: 'string',
            requestId: 'string',
            status: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SubmitIndexAddDocumentsJobResponseBody = SubmitIndexAddDocumentsJobResponseBody;
class SubmitIndexAddDocumentsJobResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SubmitIndexAddDocumentsJobResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SubmitIndexAddDocumentsJobResponse = SubmitIndexAddDocumentsJobResponse;
class SubmitIndexJobRequest extends $tea.Model {
    static names() {
        return {
            indexId: 'IndexId',
        };
    }
    static types() {
        return {
            indexId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SubmitIndexJobRequest = SubmitIndexJobRequest;
class SubmitIndexJobResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            status: 'Status',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: SubmitIndexJobResponseBodyData,
            message: 'string',
            requestId: 'string',
            status: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SubmitIndexJobResponseBody = SubmitIndexJobResponseBody;
class SubmitIndexJobResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SubmitIndexJobResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SubmitIndexJobResponse = SubmitIndexJobResponse;
class UpdateAndPublishAgentRequest extends $tea.Model {
    static names() {
        return {
            applicationConfig: 'applicationConfig',
            instructions: 'instructions',
            modelId: 'modelId',
            name: 'name',
        };
    }
    static types() {
        return {
            applicationConfig: UpdateAndPublishAgentRequestApplicationConfig,
            instructions: 'string',
            modelId: 'string',
            name: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateAndPublishAgentRequest = UpdateAndPublishAgentRequest;
class UpdateAndPublishAgentShrinkRequest extends $tea.Model {
    static names() {
        return {
            applicationConfigShrink: 'applicationConfig',
            instructions: 'instructions',
            modelId: 'modelId',
            name: 'name',
        };
    }
    static types() {
        return {
            applicationConfigShrink: 'string',
            instructions: 'string',
            modelId: 'string',
            name: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateAndPublishAgentShrinkRequest = UpdateAndPublishAgentShrinkRequest;
class UpdateAndPublishAgentResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'code',
            data: 'data',
            httpStatusCode: 'httpStatusCode',
            message: 'message',
            requestId: 'requestId',
            success: 'success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: 'string',
            httpStatusCode: 'number',
            message: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateAndPublishAgentResponseBody = UpdateAndPublishAgentResponseBody;
class UpdateAndPublishAgentResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateAndPublishAgentResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateAndPublishAgentResponse = UpdateAndPublishAgentResponse;
class UpdateFileTagRequest extends $tea.Model {
    static names() {
        return {
            tags: 'Tags',
        };
    }
    static types() {
        return {
            tags: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateFileTagRequest = UpdateFileTagRequest;
class UpdateFileTagShrinkRequest extends $tea.Model {
    static names() {
        return {
            tagsShrink: 'Tags',
        };
    }
    static types() {
        return {
            tagsShrink: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateFileTagShrinkRequest = UpdateFileTagShrinkRequest;
class UpdateFileTagResponseBody extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            data: 'Data',
            message: 'Message',
            requestId: 'RequestId',
            status: 'Status',
            success: 'Success',
        };
    }
    static types() {
        return {
            code: 'string',
            data: UpdateFileTagResponseBodyData,
            message: 'string',
            requestId: 'string',
            status: 'string',
            success: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateFileTagResponseBody = UpdateFileTagResponseBody;
class UpdateFileTagResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateFileTagResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateFileTagResponse = UpdateFileTagResponse;
class UpdateMemoryRequest extends $tea.Model {
    static names() {
        return {
            description: 'description',
        };
    }
    static types() {
        return {
            description: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateMemoryRequest = UpdateMemoryRequest;
class UpdateMemoryResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateMemoryResponseBody = UpdateMemoryResponseBody;
class UpdateMemoryResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateMemoryResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateMemoryResponse = UpdateMemoryResponse;
class UpdateMemoryNodeRequest extends $tea.Model {
    static names() {
        return {
            content: 'content',
        };
    }
    static types() {
        return {
            content: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateMemoryNodeRequest = UpdateMemoryNodeRequest;
class UpdateMemoryNodeResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateMemoryNodeResponseBody = UpdateMemoryNodeResponseBody;
class UpdateMemoryNodeResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateMemoryNodeResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateMemoryNodeResponse = UpdateMemoryNodeResponse;
class UpdatePromptTemplateRequest extends $tea.Model {
    static names() {
        return {
            content: 'content',
            name: 'name',
        };
    }
    static types() {
        return {
            content: 'string',
            name: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdatePromptTemplateRequest = UpdatePromptTemplateRequest;
class UpdatePromptTemplateResponseBody extends $tea.Model {
    static names() {
        return {
            requestId: 'requestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdatePromptTemplateResponseBody = UpdatePromptTemplateResponseBody;
class UpdatePromptTemplateResponse extends $tea.Model {
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdatePromptTemplateResponseBody,
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdatePromptTemplateResponse = UpdatePromptTemplateResponse;
class AddCategoryResponseBodyData extends $tea.Model {
    static names() {
        return {
            categoryId: 'CategoryId',
            categoryName: 'CategoryName',
        };
    }
    static types() {
        return {
            categoryId: 'string',
            categoryName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddCategoryResponseBodyData = AddCategoryResponseBodyData;
class AddFileResponseBodyData extends $tea.Model {
    static names() {
        return {
            fileId: 'FileId',
            parser: 'Parser',
        };
    }
    static types() {
        return {
            fileId: 'string',
            parser: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.AddFileResponseBodyData = AddFileResponseBodyData;
class ApplyFileUploadLeaseResponseBodyDataParam extends $tea.Model {
    static names() {
        return {
            headers: 'Headers',
            method: 'Method',
            url: 'Url',
        };
    }
    static types() {
        return {
            headers: 'any',
            method: 'string',
            url: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ApplyFileUploadLeaseResponseBodyDataParam = ApplyFileUploadLeaseResponseBodyDataParam;
class ApplyFileUploadLeaseResponseBodyData extends $tea.Model {
    static names() {
        return {
            fileUploadLeaseId: 'FileUploadLeaseId',
            param: 'Param',
            type: 'Type',
        };
    }
    static types() {
        return {
            fileUploadLeaseId: 'string',
            param: ApplyFileUploadLeaseResponseBodyDataParam,
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ApplyFileUploadLeaseResponseBodyData = ApplyFileUploadLeaseResponseBodyData;
class CreateAndPulishAgentRequestApplicationConfigHistoryConfig extends $tea.Model {
    static names() {
        return {
            enableAdbRecord: 'enableAdbRecord',
            enableRecord: 'enableRecord',
            instanceId: 'instanceId',
            region: 'region',
            storeCode: 'storeCode',
        };
    }
    static types() {
        return {
            enableAdbRecord: 'boolean',
            enableRecord: 'boolean',
            instanceId: 'string',
            region: 'string',
            storeCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAndPulishAgentRequestApplicationConfigHistoryConfig = CreateAndPulishAgentRequestApplicationConfigHistoryConfig;
class CreateAndPulishAgentRequestApplicationConfigLongTermMemory extends $tea.Model {
    static names() {
        return {
            enable: 'enable',
        };
    }
    static types() {
        return {
            enable: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAndPulishAgentRequestApplicationConfigLongTermMemory = CreateAndPulishAgentRequestApplicationConfigLongTermMemory;
class CreateAndPulishAgentRequestApplicationConfigParameters extends $tea.Model {
    static names() {
        return {
            dialogRound: 'dialogRound',
            maxTokens: 'maxTokens',
            temperature: 'temperature',
        };
    }
    static types() {
        return {
            dialogRound: 'number',
            maxTokens: 'number',
            temperature: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAndPulishAgentRequestApplicationConfigParameters = CreateAndPulishAgentRequestApplicationConfigParameters;
class CreateAndPulishAgentRequestApplicationConfigRagConfig extends $tea.Model {
    static names() {
        return {
            enableCitation: 'enableCitation',
            enableSearch: 'enableSearch',
            knowledgeBaseCodeList: 'knowledgeBaseCodeList',
            topK: 'topK',
        };
    }
    static types() {
        return {
            enableCitation: 'boolean',
            enableSearch: 'boolean',
            knowledgeBaseCodeList: { 'type': 'array', 'itemType': 'string' },
            topK: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAndPulishAgentRequestApplicationConfigRagConfig = CreateAndPulishAgentRequestApplicationConfigRagConfig;
class CreateAndPulishAgentRequestApplicationConfigSecurityConfig extends $tea.Model {
    static names() {
        return {
            processingStrategy: 'processingStrategy',
        };
    }
    static types() {
        return {
            processingStrategy: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAndPulishAgentRequestApplicationConfigSecurityConfig = CreateAndPulishAgentRequestApplicationConfigSecurityConfig;
class CreateAndPulishAgentRequestApplicationConfigTools extends $tea.Model {
    static names() {
        return {
            type: 'type',
        };
    }
    static types() {
        return {
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAndPulishAgentRequestApplicationConfigTools = CreateAndPulishAgentRequestApplicationConfigTools;
class CreateAndPulishAgentRequestApplicationConfigWorkFlows extends $tea.Model {
    static names() {
        return {
            type: 'type',
        };
    }
    static types() {
        return {
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAndPulishAgentRequestApplicationConfigWorkFlows = CreateAndPulishAgentRequestApplicationConfigWorkFlows;
class CreateAndPulishAgentRequestApplicationConfig extends $tea.Model {
    static names() {
        return {
            historyConfig: 'historyConfig',
            longTermMemory: 'longTermMemory',
            parameters: 'parameters',
            ragConfig: 'ragConfig',
            securityConfig: 'securityConfig',
            tools: 'tools',
            workFlows: 'workFlows',
        };
    }
    static types() {
        return {
            historyConfig: CreateAndPulishAgentRequestApplicationConfigHistoryConfig,
            longTermMemory: CreateAndPulishAgentRequestApplicationConfigLongTermMemory,
            parameters: CreateAndPulishAgentRequestApplicationConfigParameters,
            ragConfig: CreateAndPulishAgentRequestApplicationConfigRagConfig,
            securityConfig: CreateAndPulishAgentRequestApplicationConfigSecurityConfig,
            tools: { 'type': 'array', 'itemType': CreateAndPulishAgentRequestApplicationConfigTools },
            workFlows: { 'type': 'array', 'itemType': CreateAndPulishAgentRequestApplicationConfigWorkFlows },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateAndPulishAgentRequestApplicationConfig = CreateAndPulishAgentRequestApplicationConfig;
class CreateIndexRequestColumns extends $tea.Model {
    static names() {
        return {
            column: 'Column',
            isRecall: 'IsRecall',
            isSearch: 'IsSearch',
            name: 'Name',
            type: 'Type',
        };
    }
    static types() {
        return {
            column: 'string',
            isRecall: 'boolean',
            isSearch: 'boolean',
            name: 'string',
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateIndexRequestColumns = CreateIndexRequestColumns;
class CreateIndexRequestDataSource extends $tea.Model {
    static names() {
        return {
            credentialId: 'CredentialId',
            credentialKey: 'CredentialKey',
            database: 'Database',
            endpoint: 'Endpoint',
            isPrivateLink: 'IsPrivateLink',
            region: 'Region',
            subPath: 'SubPath',
            subType: 'SubType',
            table: 'Table',
            type: 'Type',
        };
    }
    static types() {
        return {
            credentialId: 'string',
            credentialKey: 'string',
            database: 'string',
            endpoint: 'string',
            isPrivateLink: 'boolean',
            region: 'string',
            subPath: 'string',
            subType: 'string',
            table: 'string',
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateIndexRequestDataSource = CreateIndexRequestDataSource;
class CreateIndexRequestMetaExtractColumns extends $tea.Model {
    static names() {
        return {
            desc: 'Desc',
            enableLlm: 'EnableLlm',
            enableSearch: 'EnableSearch',
            key: 'Key',
            type: 'Type',
            value: 'Value',
        };
    }
    static types() {
        return {
            desc: 'string',
            enableLlm: 'boolean',
            enableSearch: 'boolean',
            key: 'string',
            type: 'string',
            value: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateIndexRequestMetaExtractColumns = CreateIndexRequestMetaExtractColumns;
class CreateIndexResponseBodyData extends $tea.Model {
    static names() {
        return {
            id: 'Id',
        };
    }
    static types() {
        return {
            id: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.CreateIndexResponseBodyData = CreateIndexResponseBodyData;
class DeleteCategoryResponseBodyData extends $tea.Model {
    static names() {
        return {
            categoryId: 'CategoryId',
        };
    }
    static types() {
        return {
            categoryId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteCategoryResponseBodyData = DeleteCategoryResponseBodyData;
class DeleteFileResponseBodyData extends $tea.Model {
    static names() {
        return {
            fileId: 'FileId',
        };
    }
    static types() {
        return {
            fileId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteFileResponseBodyData = DeleteFileResponseBodyData;
class DeleteIndexDocumentResponseBodyData extends $tea.Model {
    static names() {
        return {
            deletedDocument: 'DeletedDocument',
        };
    }
    static types() {
        return {
            deletedDocument: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DeleteIndexDocumentResponseBodyData = DeleteIndexDocumentResponseBodyData;
class DescribeFileResponseBodyData extends $tea.Model {
    static names() {
        return {
            categoryId: 'CategoryId',
            createTime: 'CreateTime',
            fileId: 'FileId',
            fileName: 'FileName',
            fileType: 'FileType',
            parser: 'Parser',
            sizeInBytes: 'SizeInBytes',
            status: 'Status',
            tags: 'Tags',
        };
    }
    static types() {
        return {
            categoryId: 'string',
            createTime: 'string',
            fileId: 'string',
            fileName: 'string',
            fileType: 'string',
            parser: 'string',
            sizeInBytes: 'number',
            status: 'string',
            tags: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.DescribeFileResponseBodyData = DescribeFileResponseBodyData;
class GetIndexJobStatusResponseBodyDataDocuments extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            docId: 'DocId',
            docName: 'DocName',
            message: 'Message',
            status: 'Status',
        };
    }
    static types() {
        return {
            code: 'string',
            docId: 'string',
            docName: 'string',
            message: 'string',
            status: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetIndexJobStatusResponseBodyDataDocuments = GetIndexJobStatusResponseBodyDataDocuments;
class GetIndexJobStatusResponseBodyData extends $tea.Model {
    static names() {
        return {
            documents: 'Documents',
            jobId: 'JobId',
            status: 'Status',
        };
    }
    static types() {
        return {
            documents: { 'type': 'array', 'itemType': GetIndexJobStatusResponseBodyDataDocuments },
            jobId: 'string',
            status: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetIndexJobStatusResponseBodyData = GetIndexJobStatusResponseBodyData;
class GetPublishedAgentResponseBodyDataApplicationConfigHistoryConfig extends $tea.Model {
    static names() {
        return {
            enableAdbRecord: 'enableAdbRecord',
            enableRecord: 'enableRecord',
            instanceId: 'instanceId',
            region: 'region',
            storeCode: 'storeCode',
        };
    }
    static types() {
        return {
            enableAdbRecord: 'boolean',
            enableRecord: 'boolean',
            instanceId: 'string',
            region: 'string',
            storeCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPublishedAgentResponseBodyDataApplicationConfigHistoryConfig = GetPublishedAgentResponseBodyDataApplicationConfigHistoryConfig;
class GetPublishedAgentResponseBodyDataApplicationConfigLongTermMemory extends $tea.Model {
    static names() {
        return {
            enable: 'enable',
        };
    }
    static types() {
        return {
            enable: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPublishedAgentResponseBodyDataApplicationConfigLongTermMemory = GetPublishedAgentResponseBodyDataApplicationConfigLongTermMemory;
class GetPublishedAgentResponseBodyDataApplicationConfigParameters extends $tea.Model {
    static names() {
        return {
            dialogRound: 'dialogRound',
            maxTokens: 'maxTokens',
            temperature: 'temperature',
        };
    }
    static types() {
        return {
            dialogRound: 'number',
            maxTokens: 'number',
            temperature: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPublishedAgentResponseBodyDataApplicationConfigParameters = GetPublishedAgentResponseBodyDataApplicationConfigParameters;
class GetPublishedAgentResponseBodyDataApplicationConfigRagConfig extends $tea.Model {
    static names() {
        return {
            enableCitation: 'enableCitation',
            enableSearch: 'enableSearch',
            knowledgeBaseCodeList: 'knowledgeBaseCodeList',
            topK: 'topK',
        };
    }
    static types() {
        return {
            enableCitation: 'boolean',
            enableSearch: 'boolean',
            knowledgeBaseCodeList: { 'type': 'array', 'itemType': 'string' },
            topK: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPublishedAgentResponseBodyDataApplicationConfigRagConfig = GetPublishedAgentResponseBodyDataApplicationConfigRagConfig;
class GetPublishedAgentResponseBodyDataApplicationConfigSecurity extends $tea.Model {
    static names() {
        return {
            processingStrategy: 'processingStrategy',
        };
    }
    static types() {
        return {
            processingStrategy: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPublishedAgentResponseBodyDataApplicationConfigSecurity = GetPublishedAgentResponseBodyDataApplicationConfigSecurity;
class GetPublishedAgentResponseBodyDataApplicationConfigTools extends $tea.Model {
    static names() {
        return {
            type: 'type',
        };
    }
    static types() {
        return {
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPublishedAgentResponseBodyDataApplicationConfigTools = GetPublishedAgentResponseBodyDataApplicationConfigTools;
class GetPublishedAgentResponseBodyDataApplicationConfigWorkFlows extends $tea.Model {
    static names() {
        return {
            type: 'type',
        };
    }
    static types() {
        return {
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPublishedAgentResponseBodyDataApplicationConfigWorkFlows = GetPublishedAgentResponseBodyDataApplicationConfigWorkFlows;
class GetPublishedAgentResponseBodyDataApplicationConfig extends $tea.Model {
    static names() {
        return {
            historyConfig: 'historyConfig',
            longTermMemory: 'longTermMemory',
            parameters: 'parameters',
            ragConfig: 'ragConfig',
            security: 'security',
            tools: 'tools',
            workFlows: 'workFlows',
        };
    }
    static types() {
        return {
            historyConfig: GetPublishedAgentResponseBodyDataApplicationConfigHistoryConfig,
            longTermMemory: GetPublishedAgentResponseBodyDataApplicationConfigLongTermMemory,
            parameters: GetPublishedAgentResponseBodyDataApplicationConfigParameters,
            ragConfig: GetPublishedAgentResponseBodyDataApplicationConfigRagConfig,
            security: GetPublishedAgentResponseBodyDataApplicationConfigSecurity,
            tools: { 'type': 'array', 'itemType': GetPublishedAgentResponseBodyDataApplicationConfigTools },
            workFlows: { 'type': 'array', 'itemType': GetPublishedAgentResponseBodyDataApplicationConfigWorkFlows },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPublishedAgentResponseBodyDataApplicationConfig = GetPublishedAgentResponseBodyDataApplicationConfig;
class GetPublishedAgentResponseBodyData extends $tea.Model {
    static names() {
        return {
            applicationConfig: 'applicationConfig',
            code: 'code',
            instructions: 'instructions',
            modelId: 'modelId',
            name: 'name',
        };
    }
    static types() {
        return {
            applicationConfig: GetPublishedAgentResponseBodyDataApplicationConfig,
            code: 'string',
            instructions: 'string',
            modelId: 'string',
            name: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.GetPublishedAgentResponseBodyData = GetPublishedAgentResponseBodyData;
class ListCategoryResponseBodyDataCategoryList extends $tea.Model {
    static names() {
        return {
            categoryId: 'CategoryId',
            categoryName: 'CategoryName',
            categoryType: 'CategoryType',
            isDefault: 'IsDefault',
            parentCategoryId: 'ParentCategoryId',
        };
    }
    static types() {
        return {
            categoryId: 'string',
            categoryName: 'string',
            categoryType: 'string',
            isDefault: 'boolean',
            parentCategoryId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListCategoryResponseBodyDataCategoryList = ListCategoryResponseBodyDataCategoryList;
class ListCategoryResponseBodyData extends $tea.Model {
    static names() {
        return {
            categoryList: 'CategoryList',
            hasNext: 'HasNext',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            categoryList: { 'type': 'array', 'itemType': ListCategoryResponseBodyDataCategoryList },
            hasNext: 'boolean',
            maxResults: 'number',
            nextToken: 'string',
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListCategoryResponseBodyData = ListCategoryResponseBodyData;
class ListChunksResponseBodyDataNodes extends $tea.Model {
    static names() {
        return {
            metadata: 'Metadata',
            score: 'Score',
            text: 'Text',
        };
    }
    static types() {
        return {
            metadata: 'any',
            score: 'number',
            text: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListChunksResponseBodyDataNodes = ListChunksResponseBodyDataNodes;
class ListChunksResponseBodyData extends $tea.Model {
    static names() {
        return {
            nodes: 'Nodes',
            total: 'Total',
        };
    }
    static types() {
        return {
            nodes: { 'type': 'array', 'itemType': ListChunksResponseBodyDataNodes },
            total: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListChunksResponseBodyData = ListChunksResponseBodyData;
class ListFileResponseBodyDataFileList extends $tea.Model {
    static names() {
        return {
            categoryId: 'CategoryId',
            createTime: 'CreateTime',
            fileId: 'FileId',
            fileName: 'FileName',
            fileType: 'FileType',
            parser: 'Parser',
            sizeInBytes: 'SizeInBytes',
            status: 'Status',
            tags: 'Tags',
        };
    }
    static types() {
        return {
            categoryId: 'string',
            createTime: 'string',
            fileId: 'string',
            fileName: 'string',
            fileType: 'string',
            parser: 'string',
            sizeInBytes: 'number',
            status: 'string',
            tags: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListFileResponseBodyDataFileList = ListFileResponseBodyDataFileList;
class ListFileResponseBodyData extends $tea.Model {
    static names() {
        return {
            fileList: 'FileList',
            hasNext: 'HasNext',
            maxResults: 'MaxResults',
            nextToken: 'NextToken',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            fileList: { 'type': 'array', 'itemType': ListFileResponseBodyDataFileList },
            hasNext: 'boolean',
            maxResults: 'number',
            nextToken: 'string',
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListFileResponseBodyData = ListFileResponseBodyData;
class ListIndexDocumentsResponseBodyDataDocuments extends $tea.Model {
    static names() {
        return {
            code: 'Code',
            documentType: 'DocumentType',
            id: 'Id',
            message: 'Message',
            name: 'Name',
            size: 'Size',
            sourceId: 'SourceId',
            status: 'Status',
        };
    }
    static types() {
        return {
            code: 'string',
            documentType: 'string',
            id: 'string',
            message: 'string',
            name: 'string',
            size: 'number',
            sourceId: 'string',
            status: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListIndexDocumentsResponseBodyDataDocuments = ListIndexDocumentsResponseBodyDataDocuments;
class ListIndexDocumentsResponseBodyData extends $tea.Model {
    static names() {
        return {
            documents: 'Documents',
            indexId: 'IndexId',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            documents: { 'type': 'array', 'itemType': ListIndexDocumentsResponseBodyDataDocuments },
            indexId: 'string',
            pageNumber: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListIndexDocumentsResponseBodyData = ListIndexDocumentsResponseBodyData;
class ListIndicesResponseBodyDataIndices extends $tea.Model {
    static names() {
        return {
            chunkSize: 'ChunkSize',
            description: 'Description',
            documentIds: 'DocumentIds',
            embeddingModelName: 'EmbeddingModelName',
            id: 'Id',
            name: 'Name',
            overlapSize: 'OverlapSize',
            rerankMinScore: 'RerankMinScore',
            rerankModelName: 'RerankModelName',
            separator: 'Separator',
            sinkInstanceId: 'SinkInstanceId',
            sinkRegion: 'SinkRegion',
            sinkType: 'SinkType',
            sourceType: 'SourceType',
            structureType: 'StructureType',
        };
    }
    static types() {
        return {
            chunkSize: 'number',
            description: 'string',
            documentIds: { 'type': 'array', 'itemType': 'string' },
            embeddingModelName: 'string',
            id: 'string',
            name: 'string',
            overlapSize: 'number',
            rerankMinScore: 'string',
            rerankModelName: 'string',
            separator: 'string',
            sinkInstanceId: 'string',
            sinkRegion: 'string',
            sinkType: 'string',
            sourceType: 'string',
            structureType: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListIndicesResponseBodyDataIndices = ListIndicesResponseBodyDataIndices;
class ListIndicesResponseBodyData extends $tea.Model {
    static names() {
        return {
            indices: 'Indices',
            pageNumber: 'PageNumber',
            pageSize: 'PageSize',
            totalCount: 'TotalCount',
        };
    }
    static types() {
        return {
            indices: { 'type': 'array', 'itemType': ListIndicesResponseBodyDataIndices },
            pageNumber: 'number',
            pageSize: 'number',
            totalCount: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListIndicesResponseBodyData = ListIndicesResponseBodyData;
class ListMemoriesResponseBodyMemories extends $tea.Model {
    static names() {
        return {
            description: 'description',
            memoryId: 'memoryId',
        };
    }
    static types() {
        return {
            description: 'string',
            memoryId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListMemoriesResponseBodyMemories = ListMemoriesResponseBodyMemories;
class ListMemoryNodesResponseBodyMemoryNodes extends $tea.Model {
    static names() {
        return {
            content: 'content',
            memoryNodeId: 'memoryNodeId',
        };
    }
    static types() {
        return {
            content: 'string',
            memoryNodeId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListMemoryNodesResponseBodyMemoryNodes = ListMemoryNodesResponseBodyMemoryNodes;
class ListPromptTemplatesResponseBodyPromptTemplates extends $tea.Model {
    static names() {
        return {
            content: 'content',
            name: 'name',
            promptTemplateId: 'promptTemplateId',
            type: 'type',
            variables: 'variables',
        };
    }
    static types() {
        return {
            content: 'string',
            name: 'string',
            promptTemplateId: 'string',
            type: 'string',
            variables: { 'type': 'array', 'itemType': 'string' },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListPromptTemplatesResponseBodyPromptTemplates = ListPromptTemplatesResponseBodyPromptTemplates;
class ListPublishedAgentResponseBodyDataListApplicationConfigHistoryConfig extends $tea.Model {
    static names() {
        return {
            enableAdbRecord: 'enableAdbRecord',
            enableRecord: 'enableRecord',
            instanceId: 'instanceId',
            region: 'region',
            storeCode: 'storeCode',
        };
    }
    static types() {
        return {
            enableAdbRecord: 'boolean',
            enableRecord: 'boolean',
            instanceId: 'string',
            region: 'string',
            storeCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListPublishedAgentResponseBodyDataListApplicationConfigHistoryConfig = ListPublishedAgentResponseBodyDataListApplicationConfigHistoryConfig;
class ListPublishedAgentResponseBodyDataListApplicationConfigLongTermMemory extends $tea.Model {
    static names() {
        return {
            enable: 'enable',
        };
    }
    static types() {
        return {
            enable: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListPublishedAgentResponseBodyDataListApplicationConfigLongTermMemory = ListPublishedAgentResponseBodyDataListApplicationConfigLongTermMemory;
class ListPublishedAgentResponseBodyDataListApplicationConfigParameters extends $tea.Model {
    static names() {
        return {
            dialogRound: 'dialogRound',
            maxTokens: 'maxTokens',
            temperature: 'temperature',
        };
    }
    static types() {
        return {
            dialogRound: 'number',
            maxTokens: 'number',
            temperature: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListPublishedAgentResponseBodyDataListApplicationConfigParameters = ListPublishedAgentResponseBodyDataListApplicationConfigParameters;
class ListPublishedAgentResponseBodyDataListApplicationConfigRagConfig extends $tea.Model {
    static names() {
        return {
            enableCitation: 'enableCitation',
            enableSearch: 'enableSearch',
            knowledgeBaseCodeList: 'knowledgeBaseCodeList',
            topK: 'topK',
        };
    }
    static types() {
        return {
            enableCitation: 'boolean',
            enableSearch: 'boolean',
            knowledgeBaseCodeList: { 'type': 'array', 'itemType': 'string' },
            topK: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListPublishedAgentResponseBodyDataListApplicationConfigRagConfig = ListPublishedAgentResponseBodyDataListApplicationConfigRagConfig;
class ListPublishedAgentResponseBodyDataListApplicationConfigSecurity extends $tea.Model {
    static names() {
        return {
            processingStrategy: 'processingStrategy',
        };
    }
    static types() {
        return {
            processingStrategy: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListPublishedAgentResponseBodyDataListApplicationConfigSecurity = ListPublishedAgentResponseBodyDataListApplicationConfigSecurity;
class ListPublishedAgentResponseBodyDataListApplicationConfigTools extends $tea.Model {
    static names() {
        return {
            type: 'type',
        };
    }
    static types() {
        return {
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListPublishedAgentResponseBodyDataListApplicationConfigTools = ListPublishedAgentResponseBodyDataListApplicationConfigTools;
class ListPublishedAgentResponseBodyDataListApplicationConfigWorkFlows extends $tea.Model {
    static names() {
        return {
            type: 'type',
        };
    }
    static types() {
        return {
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListPublishedAgentResponseBodyDataListApplicationConfigWorkFlows = ListPublishedAgentResponseBodyDataListApplicationConfigWorkFlows;
class ListPublishedAgentResponseBodyDataListApplicationConfig extends $tea.Model {
    static names() {
        return {
            historyConfig: 'historyConfig',
            longTermMemory: 'longTermMemory',
            parameters: 'parameters',
            ragConfig: 'ragConfig',
            security: 'security',
            tools: 'tools',
            workFlows: 'workFlows',
        };
    }
    static types() {
        return {
            historyConfig: ListPublishedAgentResponseBodyDataListApplicationConfigHistoryConfig,
            longTermMemory: ListPublishedAgentResponseBodyDataListApplicationConfigLongTermMemory,
            parameters: ListPublishedAgentResponseBodyDataListApplicationConfigParameters,
            ragConfig: ListPublishedAgentResponseBodyDataListApplicationConfigRagConfig,
            security: ListPublishedAgentResponseBodyDataListApplicationConfigSecurity,
            tools: { 'type': 'array', 'itemType': ListPublishedAgentResponseBodyDataListApplicationConfigTools },
            workFlows: { 'type': 'array', 'itemType': ListPublishedAgentResponseBodyDataListApplicationConfigWorkFlows },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListPublishedAgentResponseBodyDataListApplicationConfig = ListPublishedAgentResponseBodyDataListApplicationConfig;
class ListPublishedAgentResponseBodyDataList extends $tea.Model {
    static names() {
        return {
            applicationConfig: 'applicationConfig',
            code: 'code',
            instructions: 'instructions',
            modelId: 'modelId',
            name: 'name',
        };
    }
    static types() {
        return {
            applicationConfig: ListPublishedAgentResponseBodyDataListApplicationConfig,
            code: 'string',
            instructions: 'string',
            modelId: 'string',
            name: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListPublishedAgentResponseBodyDataList = ListPublishedAgentResponseBodyDataList;
class ListPublishedAgentResponseBodyData extends $tea.Model {
    static names() {
        return {
            list: 'list',
            pageNo: 'pageNo',
            pageSize: 'pageSize',
            total: 'total',
        };
    }
    static types() {
        return {
            list: { 'type': 'array', 'itemType': ListPublishedAgentResponseBodyDataList },
            pageNo: 'number',
            pageSize: 'number',
            total: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.ListPublishedAgentResponseBodyData = ListPublishedAgentResponseBodyData;
class RetrieveRequestRerank extends $tea.Model {
    static names() {
        return {
            modelName: 'ModelName',
        };
    }
    static types() {
        return {
            modelName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveRequestRerank = RetrieveRequestRerank;
class RetrieveRequestRewrite extends $tea.Model {
    static names() {
        return {
            modelName: 'ModelName',
        };
    }
    static types() {
        return {
            modelName: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveRequestRewrite = RetrieveRequestRewrite;
class RetrieveResponseBodyDataNodes extends $tea.Model {
    static names() {
        return {
            metadata: 'Metadata',
            score: 'Score',
            text: 'Text',
        };
    }
    static types() {
        return {
            metadata: 'any',
            score: 'number',
            text: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveResponseBodyDataNodes = RetrieveResponseBodyDataNodes;
class RetrieveResponseBodyData extends $tea.Model {
    static names() {
        return {
            nodes: 'Nodes',
        };
    }
    static types() {
        return {
            nodes: { 'type': 'array', 'itemType': RetrieveResponseBodyDataNodes },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.RetrieveResponseBodyData = RetrieveResponseBodyData;
class SubmitIndexAddDocumentsJobResponseBodyData extends $tea.Model {
    static names() {
        return {
            id: 'Id',
        };
    }
    static types() {
        return {
            id: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SubmitIndexAddDocumentsJobResponseBodyData = SubmitIndexAddDocumentsJobResponseBodyData;
class SubmitIndexJobResponseBodyData extends $tea.Model {
    static names() {
        return {
            id: 'Id',
            indexId: 'IndexId',
        };
    }
    static types() {
        return {
            id: 'string',
            indexId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.SubmitIndexJobResponseBodyData = SubmitIndexJobResponseBodyData;
class UpdateAndPublishAgentRequestApplicationConfigHistoryConfig extends $tea.Model {
    static names() {
        return {
            enableAdbRecord: 'enableAdbRecord',
            enableRecord: 'enableRecord',
            instanceId: 'instanceId',
            region: 'region',
            storeCode: 'storeCode',
        };
    }
    static types() {
        return {
            enableAdbRecord: 'boolean',
            enableRecord: 'boolean',
            instanceId: 'string',
            region: 'string',
            storeCode: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateAndPublishAgentRequestApplicationConfigHistoryConfig = UpdateAndPublishAgentRequestApplicationConfigHistoryConfig;
class UpdateAndPublishAgentRequestApplicationConfigLongTermMemory extends $tea.Model {
    static names() {
        return {
            enable: 'enable',
        };
    }
    static types() {
        return {
            enable: 'boolean',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateAndPublishAgentRequestApplicationConfigLongTermMemory = UpdateAndPublishAgentRequestApplicationConfigLongTermMemory;
class UpdateAndPublishAgentRequestApplicationConfigParameters extends $tea.Model {
    static names() {
        return {
            dialogRound: 'dialogRound',
            maxTokens: 'maxTokens',
            temperature: 'temperature',
        };
    }
    static types() {
        return {
            dialogRound: 'number',
            maxTokens: 'number',
            temperature: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateAndPublishAgentRequestApplicationConfigParameters = UpdateAndPublishAgentRequestApplicationConfigParameters;
class UpdateAndPublishAgentRequestApplicationConfigRagConfig extends $tea.Model {
    static names() {
        return {
            enableCitation: 'enableCitation',
            enableSearch: 'enableSearch',
            knowledgeBaseCodeList: 'knowledgeBaseCodeList',
            topK: 'topK',
        };
    }
    static types() {
        return {
            enableCitation: 'boolean',
            enableSearch: 'boolean',
            knowledgeBaseCodeList: { 'type': 'array', 'itemType': 'string' },
            topK: 'number',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateAndPublishAgentRequestApplicationConfigRagConfig = UpdateAndPublishAgentRequestApplicationConfigRagConfig;
class UpdateAndPublishAgentRequestApplicationConfigSecurity extends $tea.Model {
    static names() {
        return {
            processingStrategy: 'processingStrategy',
        };
    }
    static types() {
        return {
            processingStrategy: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateAndPublishAgentRequestApplicationConfigSecurity = UpdateAndPublishAgentRequestApplicationConfigSecurity;
class UpdateAndPublishAgentRequestApplicationConfigTools extends $tea.Model {
    static names() {
        return {
            type: 'type',
        };
    }
    static types() {
        return {
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateAndPublishAgentRequestApplicationConfigTools = UpdateAndPublishAgentRequestApplicationConfigTools;
class UpdateAndPublishAgentRequestApplicationConfigWorkFlows extends $tea.Model {
    static names() {
        return {
            type: 'type',
        };
    }
    static types() {
        return {
            type: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateAndPublishAgentRequestApplicationConfigWorkFlows = UpdateAndPublishAgentRequestApplicationConfigWorkFlows;
class UpdateAndPublishAgentRequestApplicationConfig extends $tea.Model {
    static names() {
        return {
            historyConfig: 'historyConfig',
            longTermMemory: 'longTermMemory',
            parameters: 'parameters',
            ragConfig: 'ragConfig',
            security: 'security',
            tools: 'tools',
            workFlows: 'workFlows',
        };
    }
    static types() {
        return {
            historyConfig: UpdateAndPublishAgentRequestApplicationConfigHistoryConfig,
            longTermMemory: UpdateAndPublishAgentRequestApplicationConfigLongTermMemory,
            parameters: UpdateAndPublishAgentRequestApplicationConfigParameters,
            ragConfig: UpdateAndPublishAgentRequestApplicationConfigRagConfig,
            security: UpdateAndPublishAgentRequestApplicationConfigSecurity,
            tools: { 'type': 'array', 'itemType': UpdateAndPublishAgentRequestApplicationConfigTools },
            workFlows: { 'type': 'array', 'itemType': UpdateAndPublishAgentRequestApplicationConfigWorkFlows },
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateAndPublishAgentRequestApplicationConfig = UpdateAndPublishAgentRequestApplicationConfig;
class UpdateFileTagResponseBodyData extends $tea.Model {
    static names() {
        return {
            fileId: 'FileId',
        };
    }
    static types() {
        return {
            fileId: 'string',
        };
    }
    constructor(map) {
        super(map);
    }
}
exports.UpdateFileTagResponseBodyData = UpdateFileTagResponseBodyData;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._endpointRule = "";
        this.checkConfig(config);
        this._endpoint = this.getEndpoint("bailian", this._regionId, this._endpointRule, this._network, this._suffix, this._endpointMap, this._endpoint);
    }
    getEndpoint(productId, regionId, endpointRule, network, suffix, endpointMap, endpoint) {
        if (!tea_util_1.default.empty(endpoint)) {
            return endpoint;
        }
        if (!tea_util_1.default.isUnset(endpointMap) && !tea_util_1.default.empty(endpointMap[regionId])) {
            return endpointMap[regionId];
        }
        return endpoint_util_1.default.getEndpointRules(productId, regionId, endpointRule, network, suffix);
    }
    /**
     * @param request - AddCategoryRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns AddCategoryResponse
     */
    async addCategoryWithOptions(WorkspaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.categoryName)) {
            body["CategoryName"] = request.categoryName;
        }
        if (!tea_util_1.default.isUnset(request.categoryType)) {
            body["CategoryType"] = request.categoryType;
        }
        if (!tea_util_1.default.isUnset(request.parentCategoryId)) {
            body["ParentCategoryId"] = request.parentCategoryId;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddCategory",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(WorkspaceId)}/datacenter/category/`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new AddCategoryResponse({}));
    }
    /**
     * @param request - AddCategoryRequest
     * @returns AddCategoryResponse
     */
    async addCategory(WorkspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.addCategoryWithOptions(WorkspaceId, request, headers, runtime);
    }
    /**
     * Imports an unstructured document stored in the temporary storage space to Data Management.
     *
     * @remarks
     *   Before you call this operation, make sure that you have obtained the lease and uploaded the document to the temporary storage space by using the [ApplyFileUploadLease](https://help.aliyun.com/zh/model-studio/developer-reference/api-bailian-2023-12-29-applyfileuploadlease) operation. For more information, see [Upload files by calling API](https://help.aliyun.com/zh/model-studio/developer-reference/upload-files-by-calling-api).
     * >  After you call this operation, the used lease ID expires immediately. Do not use the same lease ID to submit new requests.
     * *   You must call this operation within 12 hours after you call the [ApplyFileUploadLease](https://help.aliyun.com/zh/model-studio/developer-reference/api-bailian-2023-12-29-applyfileuploadlease) operation. Otherwise, the lease expires and the request fails.
     * *   After you call this operation, the system parses and imports your document. The process takes some time.
     * *   This interface is not idempotent.
     *
     * @param tmpReq - AddFileRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns AddFileResponse
     */
    async addFileWithOptions(WorkspaceId, tmpReq, headers, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new AddFileShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.tags)) {
            request.tagsShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.tags, "Tags", "json");
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.categoryId)) {
            body["CategoryId"] = request.categoryId;
        }
        if (!tea_util_1.default.isUnset(request.leaseId)) {
            body["LeaseId"] = request.leaseId;
        }
        if (!tea_util_1.default.isUnset(request.parser)) {
            body["Parser"] = request.parser;
        }
        if (!tea_util_1.default.isUnset(request.tagsShrink)) {
            body["Tags"] = request.tagsShrink;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddFile",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(WorkspaceId)}/datacenter/file`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new AddFileResponse({}));
    }
    /**
     * Imports an unstructured document stored in the temporary storage space to Data Management.
     *
     * @remarks
     *   Before you call this operation, make sure that you have obtained the lease and uploaded the document to the temporary storage space by using the [ApplyFileUploadLease](https://help.aliyun.com/zh/model-studio/developer-reference/api-bailian-2023-12-29-applyfileuploadlease) operation. For more information, see [Upload files by calling API](https://help.aliyun.com/zh/model-studio/developer-reference/upload-files-by-calling-api).
     * >  After you call this operation, the used lease ID expires immediately. Do not use the same lease ID to submit new requests.
     * *   You must call this operation within 12 hours after you call the [ApplyFileUploadLease](https://help.aliyun.com/zh/model-studio/developer-reference/api-bailian-2023-12-29-applyfileuploadlease) operation. Otherwise, the lease expires and the request fails.
     * *   After you call this operation, the system parses and imports your document. The process takes some time.
     * *   This interface is not idempotent.
     *
     * @param request - AddFileRequest
     * @returns AddFileResponse
     */
    async addFile(WorkspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.addFileWithOptions(WorkspaceId, request, headers, runtime);
    }
    /**
     * Applies for a document upload lease to upload a document.
     *
     * @remarks
     *   This operation returns an HTTP URL that can be used to upload an unstructured document (the lease) and parameters required for the upload. Structured documents are not supported.
     * *   The HTTP URL returned by this operation is valid only for minutes. Upload the document before the URL expires.
     * *   After you apply for a lease and upload a document, the document is stored in a temporary storage space for 12 hours.
     * *   This interface is not idempotent.
     *
     * @param request - ApplyFileUploadLeaseRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ApplyFileUploadLeaseResponse
     */
    async applyFileUploadLeaseWithOptions(CategoryId, WorkspaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.fileName)) {
            body["FileName"] = request.fileName;
        }
        if (!tea_util_1.default.isUnset(request.md5)) {
            body["Md5"] = request.md5;
        }
        if (!tea_util_1.default.isUnset(request.sizeInBytes)) {
            body["SizeInBytes"] = request.sizeInBytes;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ApplyFileUploadLease",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(WorkspaceId)}/datacenter/category/${openapi_util_1.default.getEncodeParam(CategoryId)}`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ApplyFileUploadLeaseResponse({}));
    }
    /**
     * Applies for a document upload lease to upload a document.
     *
     * @remarks
     *   This operation returns an HTTP URL that can be used to upload an unstructured document (the lease) and parameters required for the upload. Structured documents are not supported.
     * *   The HTTP URL returned by this operation is valid only for minutes. Upload the document before the URL expires.
     * *   After you apply for a lease and upload a document, the document is stored in a temporary storage space for 12 hours.
     * *   This interface is not idempotent.
     *
     * @param request - ApplyFileUploadLeaseRequest
     * @returns ApplyFileUploadLeaseResponse
     */
    async applyFileUploadLease(CategoryId, WorkspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.applyFileUploadLeaseWithOptions(CategoryId, WorkspaceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param tmpReq - CreateAndPulishAgentRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateAndPulishAgentResponse
     */
    async createAndPulishAgentWithOptions(workspaceId, tmpReq, headers, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new CreateAndPulishAgentShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.applicationConfig)) {
            request.applicationConfigShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.applicationConfig, "applicationConfig", "json");
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.applicationConfigShrink)) {
            body["applicationConfig"] = request.applicationConfigShrink;
        }
        if (!tea_util_1.default.isUnset(request.instructions)) {
            body["instructions"] = request.instructions;
        }
        if (!tea_util_1.default.isUnset(request.modelId)) {
            body["modelId"] = request.modelId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateAndPulishAgent",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(workspaceId)}/application/agents`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateAndPulishAgentResponse({}));
    }
    /**
     * 
     *
     * @param request - CreateAndPulishAgentRequest
     * @returns CreateAndPulishAgentResponse
     */
    async createAndPulishAgent(workspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.createAndPulishAgentWithOptions(workspaceId, request, headers, runtime);
    }
    /**
     * Creates an unstructured knowledge base and imports one or more parsed documents into the knowledge base. You cannot create a structured knowledge base by calling an API operation. Use the console instead.
     *
     * @remarks
     * 1.  You must first upload documents to [Data Management](https://bailian.console.aliyun.com/#/data-center) and obtain the `FileId`. The documents are the knowledge source of the knowledge base. For more information, see [Import Data](https://www.alibabacloud.com/help/en/model-studio/user-guide/data-import-instructions).
     * 2.  This operation only initializes a knowledge base creation job. You must also call the [SubmitIndexJob](https://www.alibabacloud.com/help/en/model-studio/developer-reference/api-bailian-2023-12-29-submitindexjob) operation to complete the job.
     * 3.  This interface is not idempotent.
     *
     * @param tmpReq - CreateIndexRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateIndexResponse
     */
    async createIndexWithOptions(WorkspaceId, tmpReq, headers, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new CreateIndexShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.categoryIds)) {
            request.categoryIdsShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.categoryIds, "CategoryIds", "json");
        }
        if (!tea_util_1.default.isUnset(tmpReq.columns)) {
            request.columnsShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.columns, "Columns", "json");
        }
        if (!tea_util_1.default.isUnset(tmpReq.dataSource)) {
            request.dataSourceShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.dataSource, "DataSource", "json");
        }
        if (!tea_util_1.default.isUnset(tmpReq.documentIds)) {
            request.documentIdsShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.documentIds, "DocumentIds", "json");
        }
        if (!tea_util_1.default.isUnset(tmpReq.metaExtractColumns)) {
            request.metaExtractColumnsShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.metaExtractColumns, "metaExtractColumns", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.categoryIdsShrink)) {
            query["CategoryIds"] = request.categoryIdsShrink;
        }
        if (!tea_util_1.default.isUnset(request.chunkSize)) {
            query["ChunkSize"] = request.chunkSize;
        }
        if (!tea_util_1.default.isUnset(request.columnsShrink)) {
            query["Columns"] = request.columnsShrink;
        }
        if (!tea_util_1.default.isUnset(request.dataSourceShrink)) {
            query["DataSource"] = request.dataSourceShrink;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            query["Description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.documentIdsShrink)) {
            query["DocumentIds"] = request.documentIdsShrink;
        }
        if (!tea_util_1.default.isUnset(request.embeddingModelName)) {
            query["EmbeddingModelName"] = request.embeddingModelName;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            query["Name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.overlapSize)) {
            query["OverlapSize"] = request.overlapSize;
        }
        if (!tea_util_1.default.isUnset(request.rerankMinScore)) {
            query["RerankMinScore"] = request.rerankMinScore;
        }
        if (!tea_util_1.default.isUnset(request.rerankModelName)) {
            query["RerankModelName"] = request.rerankModelName;
        }
        if (!tea_util_1.default.isUnset(request.separator)) {
            query["Separator"] = request.separator;
        }
        if (!tea_util_1.default.isUnset(request.sinkInstanceId)) {
            query["SinkInstanceId"] = request.sinkInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.sinkRegion)) {
            query["SinkRegion"] = request.sinkRegion;
        }
        if (!tea_util_1.default.isUnset(request.sinkType)) {
            query["SinkType"] = request.sinkType;
        }
        if (!tea_util_1.default.isUnset(request.sourceType)) {
            query["SourceType"] = request.sourceType;
        }
        if (!tea_util_1.default.isUnset(request.structureType)) {
            query["StructureType"] = request.structureType;
        }
        if (!tea_util_1.default.isUnset(request.metaExtractColumnsShrink)) {
            query["metaExtractColumns"] = request.metaExtractColumnsShrink;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateIndex",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(WorkspaceId)}/index/create`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateIndexResponse({}));
    }
    /**
     * Creates an unstructured knowledge base and imports one or more parsed documents into the knowledge base. You cannot create a structured knowledge base by calling an API operation. Use the console instead.
     *
     * @remarks
     * 1.  You must first upload documents to [Data Management](https://bailian.console.aliyun.com/#/data-center) and obtain the `FileId`. The documents are the knowledge source of the knowledge base. For more information, see [Import Data](https://www.alibabacloud.com/help/en/model-studio/user-guide/data-import-instructions).
     * 2.  This operation only initializes a knowledge base creation job. You must also call the [SubmitIndexJob](https://www.alibabacloud.com/help/en/model-studio/developer-reference/api-bailian-2023-12-29-submitindexjob) operation to complete the job.
     * 3.  This interface is not idempotent.
     *
     * @param request - CreateIndexRequest
     * @returns CreateIndexResponse
     */
    async createIndex(WorkspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.createIndexWithOptions(WorkspaceId, request, headers, runtime);
    }
    /**
     * Memory
     *
     * @param request - CreateMemoryRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateMemoryResponse
     */
    async createMemoryWithOptions(workspaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            query["description"] = request.description;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateMemory",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(workspaceId)}/memories`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateMemoryResponse({}));
    }
    /**
     * Memory
     *
     * @param request - CreateMemoryRequest
     * @returns CreateMemoryResponse
     */
    async createMemory(workspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.createMemoryWithOptions(workspaceId, request, headers, runtime);
    }
    /**
     * Node
     *
     * @param request - CreateMemoryNodeRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreateMemoryNodeResponse
     */
    async createMemoryNodeWithOptions(workspaceId, memoryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.content)) {
            query["content"] = request.content;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreateMemoryNode",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(workspaceId)}/memories/${openapi_util_1.default.getEncodeParam(memoryId)}/memoryNodes`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreateMemoryNodeResponse({}));
    }
    /**
     * Node
     *
     * @param request - CreateMemoryNodeRequest
     * @returns CreateMemoryNodeResponse
     */
    async createMemoryNode(workspaceId, memoryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.createMemoryNodeWithOptions(workspaceId, memoryId, request, headers, runtime);
    }
    /**
     * Prompt
     *
     * @param request - CreatePromptTemplateRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns CreatePromptTemplateResponse
     */
    async createPromptTemplateWithOptions(workspaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.content)) {
            query["content"] = request.content;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            query["name"] = request.name;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CreatePromptTemplate",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(workspaceId)}/promptTemplates`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new CreatePromptTemplateResponse({}));
    }
    /**
     * Prompt
     *
     * @param request - CreatePromptTemplateRequest
     * @returns CreatePromptTemplateResponse
     */
    async createPromptTemplate(workspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.createPromptTemplateWithOptions(workspaceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DeleteAgentResponse
     */
    async deleteAgentWithOptions(workspaceId, appCode, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DeleteAgent",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(workspaceId)}/application/agents/${openapi_util_1.default.getEncodeParam(appCode)}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteAgentResponse({}));
    }
    /**
     * 
     * @returns DeleteAgentResponse
     */
    async deleteAgent(workspaceId, appCode) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deleteAgentWithOptions(workspaceId, appCode, headers, runtime);
    }
    /**
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DeleteCategoryResponse
     */
    async deleteCategoryWithOptions(CategoryId, WorkspaceId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DeleteCategory",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(WorkspaceId)}/datacenter/category/${openapi_util_1.default.getEncodeParam(CategoryId)}/`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteCategoryResponse({}));
    }
    /**
     * @returns DeleteCategoryResponse
     */
    async deleteCategory(CategoryId, WorkspaceId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deleteCategoryWithOptions(CategoryId, WorkspaceId, headers, runtime);
    }
    /**
     * 
     *
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DeleteFileResponse
     */
    async deleteFileWithOptions(FileId, WorkspaceId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DeleteFile",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(WorkspaceId)}/datacenter/file/${openapi_util_1.default.getEncodeParam(FileId)}/`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteFileResponse({}));
    }
    /**
     * 
     * @returns DeleteFileResponse
     */
    async deleteFile(FileId, WorkspaceId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deleteFileWithOptions(FileId, WorkspaceId, headers, runtime);
    }
    /**
     * Deletes a specified knowledge base permanently.
     *
     * @remarks
     *   Before you call this operation, make sure that your knowledge base is created and is not deleted. That is, the primary key ID of the knowledge base `IndexId` is valid.
     * *   If a knowledge base is being called by an application, disassociate the knowledge base before you can delete it. To disassociate the knowledge base, you must use the console. For more information, see [Create a knowledge base](https://www.alibabacloud.com/help/en/model-studio/user-guide/rag-knowledge-base).
     * *   After you delete a knowledge base, it cannot be recovered. We recommend that you proceed with caution.
     * *   Imported documents are not deleted from the [Data Management](https://bailian.console.aliyun.com/#/data-center) if you call this operation.
     * *   This interface is idempotent.
     *
     * @param request - DeleteIndexRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DeleteIndexResponse
     */
    async deleteIndexWithOptions(WorkspaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.indexId)) {
            query["IndexId"] = request.indexId;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteIndex",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(WorkspaceId)}/index/delete`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteIndexResponse({}));
    }
    /**
     * Deletes a specified knowledge base permanently.
     *
     * @remarks
     *   Before you call this operation, make sure that your knowledge base is created and is not deleted. That is, the primary key ID of the knowledge base `IndexId` is valid.
     * *   If a knowledge base is being called by an application, disassociate the knowledge base before you can delete it. To disassociate the knowledge base, you must use the console. For more information, see [Create a knowledge base](https://www.alibabacloud.com/help/en/model-studio/user-guide/rag-knowledge-base).
     * *   After you delete a knowledge base, it cannot be recovered. We recommend that you proceed with caution.
     * *   Imported documents are not deleted from the [Data Management](https://bailian.console.aliyun.com/#/data-center) if you call this operation.
     * *   This interface is idempotent.
     *
     * @param request - DeleteIndexRequest
     * @returns DeleteIndexResponse
     */
    async deleteIndex(WorkspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deleteIndexWithOptions(WorkspaceId, request, headers, runtime);
    }
    /**
     * Deletes one or more documents from a specified unstructured knowledge base permanently.
     *
     * @remarks
     *   Before you call this operation, make sure that your knowledge base is created and is not deleted. That is, the primary key ID of the knowledge base `IndexId` is valid.
     * *   Only documents with the INSERT_ERROR and FINISH states can be deleted. To query the status of documents in a specified knowledge base, call the [ListIndexDocuments](https://www.alibabacloud.com/help/en/model-studio/developer-reference/api-bailian-2023-12-29-listindexdocuments) operation.
     * *   After you delete a document, it cannot be recovered and the [Retrieve](https://www.alibabacloud.com/help/en/model-studio/developer-reference/api-bailian-2023-12-29-retrieve) operation cannot query information about the document. We recommend that you proceed with caution.
     * *   Imported documents are not deleted from the [Data Management](https://bailian.console.aliyun.com/#/data-center) if you call this operation.
     * *   This interface is idempotent.
     *
     * @param tmpReq - DeleteIndexDocumentRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DeleteIndexDocumentResponse
     */
    async deleteIndexDocumentWithOptions(WorkspaceId, tmpReq, headers, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new DeleteIndexDocumentShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.documentIds)) {
            request.documentIdsShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.documentIds, "DocumentIds", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.documentIdsShrink)) {
            query["DocumentIds"] = request.documentIdsShrink;
        }
        if (!tea_util_1.default.isUnset(request.indexId)) {
            query["IndexId"] = request.indexId;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteIndexDocument",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(WorkspaceId)}/index/delete_index_document`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteIndexDocumentResponse({}));
    }
    /**
     * Deletes one or more documents from a specified unstructured knowledge base permanently.
     *
     * @remarks
     *   Before you call this operation, make sure that your knowledge base is created and is not deleted. That is, the primary key ID of the knowledge base `IndexId` is valid.
     * *   Only documents with the INSERT_ERROR and FINISH states can be deleted. To query the status of documents in a specified knowledge base, call the [ListIndexDocuments](https://www.alibabacloud.com/help/en/model-studio/developer-reference/api-bailian-2023-12-29-listindexdocuments) operation.
     * *   After you delete a document, it cannot be recovered and the [Retrieve](https://www.alibabacloud.com/help/en/model-studio/developer-reference/api-bailian-2023-12-29-retrieve) operation cannot query information about the document. We recommend that you proceed with caution.
     * *   Imported documents are not deleted from the [Data Management](https://bailian.console.aliyun.com/#/data-center) if you call this operation.
     * *   This interface is idempotent.
     *
     * @param request - DeleteIndexDocumentRequest
     * @returns DeleteIndexDocumentResponse
     */
    async deleteIndexDocument(WorkspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deleteIndexDocumentWithOptions(WorkspaceId, request, headers, runtime);
    }
    /**
     * memory
     *
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DeleteMemoryResponse
     */
    async deleteMemoryWithOptions(workspaceId, memoryId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DeleteMemory",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(workspaceId)}/memories/${openapi_util_1.default.getEncodeParam(memoryId)}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteMemoryResponse({}));
    }
    /**
     * memory
     * @returns DeleteMemoryResponse
     */
    async deleteMemory(workspaceId, memoryId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deleteMemoryWithOptions(workspaceId, memoryId, headers, runtime);
    }
    /**
     * Node
     *
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DeleteMemoryNodeResponse
     */
    async deleteMemoryNodeWithOptions(workspaceId, memoryId, memoryNodeId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DeleteMemoryNode",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(workspaceId)}/memories/${openapi_util_1.default.getEncodeParam(memoryId)}/memoryNodes/${openapi_util_1.default.getEncodeParam(memoryNodeId)}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeleteMemoryNodeResponse({}));
    }
    /**
     * Node
     * @returns DeleteMemoryNodeResponse
     */
    async deleteMemoryNode(workspaceId, memoryId, memoryNodeId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deleteMemoryNodeWithOptions(workspaceId, memoryId, memoryNodeId, headers, runtime);
    }
    /**
     * IdPrompt
     *
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DeletePromptTemplateResponse
     */
    async deletePromptTemplateWithOptions(workspaceId, promptTemplateId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DeletePromptTemplate",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(workspaceId)}/promptTemplates/${openapi_util_1.default.getEncodeParam(promptTemplateId)}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DeletePromptTemplateResponse({}));
    }
    /**
     * IdPrompt
     * @returns DeletePromptTemplateResponse
     */
    async deletePromptTemplate(workspaceId, promptTemplateId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deletePromptTemplateWithOptions(workspaceId, promptTemplateId, headers, runtime);
    }
    /**
     * Queries the details of an unstructured document.
     *
     * @remarks
     * Before you call this API, make sure that your document is uploaded to the [Data Management](https://bailian.console.aliyun.com/knowledge-base#/data-center) page of Alibaba Cloud Model Studio.
     * *   You can also call this operation to query unstructured documents that you upload on the [Data Management](https://bailian.console.aliyun.com/knowledge-base#/data-center) page.
     * *   This operation is idempotent.
     * **Throttling:** Make sure that the interval between the two queries is at least 15 seconds. Otherwise, you may trigger system throttling. If throttling is triggered, try again later.
     *
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns DescribeFileResponse
     */
    async describeFileWithOptions(WorkspaceId, FileId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DescribeFile",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(WorkspaceId)}/datacenter/file/${openapi_util_1.default.getEncodeParam(FileId)}/`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new DescribeFileResponse({}));
    }
    /**
     * Queries the details of an unstructured document.
     *
     * @remarks
     * Before you call this API, make sure that your document is uploaded to the [Data Management](https://bailian.console.aliyun.com/knowledge-base#/data-center) page of Alibaba Cloud Model Studio.
     * *   You can also call this operation to query unstructured documents that you upload on the [Data Management](https://bailian.console.aliyun.com/knowledge-base#/data-center) page.
     * *   This operation is idempotent.
     * **Throttling:** Make sure that the interval between the two queries is at least 15 seconds. Otherwise, you may trigger system throttling. If throttling is triggered, try again later.
     * @returns DescribeFileResponse
     */
    async describeFile(WorkspaceId, FileId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.describeFileWithOptions(WorkspaceId, FileId, headers, runtime);
    }
    /**
     * Queries the current status of a specified knowledge base creation or add document job.
     *
     * @remarks
     * 1.  A knowledge base job is running. You can call the [SubmitIndexJob](https://www.alibabacloud.com/help/en/model-studio/developer-reference/api-bailian-2023-12-29-submitindexjob) operation to create a creation job or the [SubmitIndexAddDocumentsJob](https://www.alibabacloud.com/help/en/model-studio/developer-reference/api-bailian-2023-12-29-submitindexadddocumentsjob) operation to create a add document job. Then, obtain the `JobId` returned by the operations.
     * 2.  We recommend that you call this operation at intervals of more than 5 seconds.
     * 3.  This interface is idempotent.
     *
     * @param request - GetIndexJobStatusRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetIndexJobStatusResponse
     */
    async getIndexJobStatusWithOptions(WorkspaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.indexId)) {
            query["IndexId"] = request.indexId;
        }
        if (!tea_util_1.default.isUnset(request.jobId)) {
            query["JobId"] = request.jobId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["pageSize"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetIndexJobStatus",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(WorkspaceId)}/index/job/status`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetIndexJobStatusResponse({}));
    }
    /**
     * Queries the current status of a specified knowledge base creation or add document job.
     *
     * @remarks
     * 1.  A knowledge base job is running. You can call the [SubmitIndexJob](https://www.alibabacloud.com/help/en/model-studio/developer-reference/api-bailian-2023-12-29-submitindexjob) operation to create a creation job or the [SubmitIndexAddDocumentsJob](https://www.alibabacloud.com/help/en/model-studio/developer-reference/api-bailian-2023-12-29-submitindexadddocumentsjob) operation to create a add document job. Then, obtain the `JobId` returned by the operations.
     * 2.  We recommend that you call this operation at intervals of more than 5 seconds.
     * 3.  This interface is idempotent.
     *
     * @param request - GetIndexJobStatusRequest
     * @returns GetIndexJobStatusResponse
     */
    async getIndexJobStatus(WorkspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.getIndexJobStatusWithOptions(WorkspaceId, request, headers, runtime);
    }
    /**
     * memory
     *
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetMemoryResponse
     */
    async getMemoryWithOptions(workspaceId, memoryId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "GetMemory",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(workspaceId)}/memories/${openapi_util_1.default.getEncodeParam(memoryId)}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetMemoryResponse({}));
    }
    /**
     * memory
     * @returns GetMemoryResponse
     */
    async getMemory(workspaceId, memoryId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.getMemoryWithOptions(workspaceId, memoryId, headers, runtime);
    }
    /**
     * Node
     *
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetMemoryNodeResponse
     */
    async getMemoryNodeWithOptions(workspaceId, memoryId, memoryNodeId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "GetMemoryNode",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(workspaceId)}/memories/${openapi_util_1.default.getEncodeParam(memoryId)}/memoryNodes/${openapi_util_1.default.getEncodeParam(memoryNodeId)}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetMemoryNodeResponse({}));
    }
    /**
     * Node
     * @returns GetMemoryNodeResponse
     */
    async getMemoryNode(workspaceId, memoryId, memoryNodeId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.getMemoryNodeWithOptions(workspaceId, memoryId, memoryNodeId, headers, runtime);
    }
    /**
     * IdPrompt
     *
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetPromptTemplateResponse
     */
    async getPromptTemplateWithOptions(workspaceId, promptTemplateId, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "GetPromptTemplate",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(workspaceId)}/promptTemplates/${openapi_util_1.default.getEncodeParam(promptTemplateId)}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetPromptTemplateResponse({}));
    }
    /**
     * IdPrompt
     * @returns GetPromptTemplateResponse
     */
    async getPromptTemplate(workspaceId, promptTemplateId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.getPromptTemplateWithOptions(workspaceId, promptTemplateId, headers, runtime);
    }
    /**
     * 
     *
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns GetPublishedAgentResponse
     */
    async getPublishedAgentWithOptions(workspaceId, appCode, headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "GetPublishedAgent",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(workspaceId)}/application/agents/${openapi_util_1.default.getEncodeParam(appCode)}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new GetPublishedAgentResponse({}));
    }
    /**
     * 
     * @returns GetPublishedAgentResponse
     */
    async getPublishedAgent(workspaceId, appCode) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.getPublishedAgentWithOptions(workspaceId, appCode, headers, runtime);
    }
    /**
     * ListCategory
     *
     * @param request - ListCategoryRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ListCategoryResponse
     */
    async listCategoryWithOptions(WorkspaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.categoryType)) {
            body["CategoryType"] = request.categoryType;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["MaxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["NextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.parentCategoryId)) {
            body["ParentCategoryId"] = request.parentCategoryId;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ListCategory",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(WorkspaceId)}/datacenter/categories`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListCategoryResponse({}));
    }
    /**
     * ListCategory
     *
     * @param request - ListCategoryRequest
     * @returns ListCategoryResponse
     */
    async listCategory(WorkspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.listCategoryWithOptions(WorkspaceId, request, headers, runtime);
    }
    /**
     * For unstructured knowledge base, obtains the details of all chunks of a specified document; for structured knowledge base, obtains the details of all chunks.
     *
     * @remarks
     *   Before you call this operation, make sure that your knowledge base is created and is not deleted. That is, the primary key ID of the knowledge base `IndexId` is valid.
     * *   This interface is idempotent.
     *
     * @param request - ListChunksRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ListChunksResponse
     */
    async listChunksWithOptions(WorkspaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.fields)) {
            body["Fields"] = request.fields;
        }
        if (!tea_util_1.default.isUnset(request.filed)) {
            body["Filed"] = request.filed;
        }
        if (!tea_util_1.default.isUnset(request.indexId)) {
            body["IndexId"] = request.indexId;
        }
        if (!tea_util_1.default.isUnset(request.pageNum)) {
            body["PageNum"] = request.pageNum;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["PageSize"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ListChunks",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(WorkspaceId)}/index/list_chunks`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListChunksResponse({}));
    }
    /**
     * For unstructured knowledge base, obtains the details of all chunks of a specified document; for structured knowledge base, obtains the details of all chunks.
     *
     * @remarks
     *   Before you call this operation, make sure that your knowledge base is created and is not deleted. That is, the primary key ID of the knowledge base `IndexId` is valid.
     * *   This interface is idempotent.
     *
     * @param request - ListChunksRequest
     * @returns ListChunksResponse
     */
    async listChunks(WorkspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.listChunksWithOptions(WorkspaceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - ListFileRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ListFileResponse
     */
    async listFileWithOptions(WorkspaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.categoryId)) {
            query["CategoryId"] = request.categoryId;
        }
        if (!tea_util_1.default.isUnset(request.fileName)) {
            query["FileName"] = request.fileName;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["MaxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["NextToken"] = request.nextToken;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListFile",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(WorkspaceId)}/datacenter/files`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListFileResponse({}));
    }
    /**
     * 
     *
     * @param request - ListFileRequest
     * @returns ListFileResponse
     */
    async listFile(WorkspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.listFileWithOptions(WorkspaceId, request, headers, runtime);
    }
    /**
     * Queries the details of one or more documents in a specified knowledge base.
     *
     * @remarks
     *   Before you call this operation, make sure that your knowledge base is created and is not deleted. That is, the primary key ID of the knowledge base `IndexId` is valid.
     * *   This interface is idempotent.
     *
     * @param request - ListIndexDocumentsRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ListIndexDocumentsResponse
     */
    async listIndexDocumentsWithOptions(WorkspaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.documentName)) {
            query["DocumentName"] = request.documentName;
        }
        if (!tea_util_1.default.isUnset(request.documentStatus)) {
            query["DocumentStatus"] = request.documentStatus;
        }
        if (!tea_util_1.default.isUnset(request.indexId)) {
            query["IndexId"] = request.indexId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListIndexDocuments",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(WorkspaceId)}/index/list_index_documents`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListIndexDocumentsResponse({}));
    }
    /**
     * Queries the details of one or more documents in a specified knowledge base.
     *
     * @remarks
     *   Before you call this operation, make sure that your knowledge base is created and is not deleted. That is, the primary key ID of the knowledge base `IndexId` is valid.
     * *   This interface is idempotent.
     *
     * @param request - ListIndexDocumentsRequest
     * @returns ListIndexDocumentsResponse
     */
    async listIndexDocuments(WorkspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.listIndexDocumentsWithOptions(WorkspaceId, request, headers, runtime);
    }
    /**
     * Lists knowledge bases in a specified workspace.
     *
     * @remarks
     * This interface is idempotent.
     *
     * @param request - ListIndicesRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ListIndicesResponse
     */
    async listIndicesWithOptions(WorkspaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.indexName)) {
            query["IndexName"] = request.indexName;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["PageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["PageSize"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListIndices",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(WorkspaceId)}/index/list_indices`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListIndicesResponse({}));
    }
    /**
     * Lists knowledge bases in a specified workspace.
     *
     * @remarks
     * This interface is idempotent.
     *
     * @param request - ListIndicesRequest
     * @returns ListIndicesResponse
     */
    async listIndices(WorkspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.listIndicesWithOptions(WorkspaceId, request, headers, runtime);
    }
    /**
     * memory
     *
     * @param request - ListMemoriesRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ListMemoriesResponse
     */
    async listMemoriesWithOptions(workspaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListMemories",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(workspaceId)}/memories`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListMemoriesResponse({}));
    }
    /**
     * memory
     *
     * @param request - ListMemoriesRequest
     * @returns ListMemoriesResponse
     */
    async listMemories(workspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.listMemoriesWithOptions(workspaceId, request, headers, runtime);
    }
    /**
     * Node
     *
     * @param request - ListMemoryNodesRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ListMemoryNodesResponse
     */
    async listMemoryNodesWithOptions(workspaceId, memoryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListMemoryNodes",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(workspaceId)}/memories/${openapi_util_1.default.getEncodeParam(memoryId)}/memoryNodes`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListMemoryNodesResponse({}));
    }
    /**
     * Node
     *
     * @param request - ListMemoryNodesRequest
     * @returns ListMemoryNodesResponse
     */
    async listMemoryNodes(workspaceId, memoryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.listMemoryNodesWithOptions(workspaceId, memoryId, request, headers, runtime);
    }
    /**
     * Prompt
     *
     * @param request - ListPromptTemplatesRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ListPromptTemplatesResponse
     */
    async listPromptTemplatesWithOptions(workspaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            query["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["type"] = request.type;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListPromptTemplates",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(workspaceId)}/promptTemplates`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListPromptTemplatesResponse({}));
    }
    /**
     * Prompt
     *
     * @param request - ListPromptTemplatesRequest
     * @returns ListPromptTemplatesResponse
     */
    async listPromptTemplates(workspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.listPromptTemplatesWithOptions(workspaceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param request - ListPublishedAgentRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns ListPublishedAgentResponse
     */
    async listPublishedAgentWithOptions(workspaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.pageNo)) {
            query["pageNo"] = request.pageNo;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["pageSize"] = request.pageSize;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListPublishedAgent",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(workspaceId)}/application/agents`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new ListPublishedAgentResponse({}));
    }
    /**
     * 
     *
     * @param request - ListPublishedAgentRequest
     * @returns ListPublishedAgentResponse
     */
    async listPublishedAgent(workspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.listPublishedAgentWithOptions(workspaceId, request, headers, runtime);
    }
    /**
     * Queries information from a specified knowledge base.
     *
     * @remarks
     *   Before you call this operation, make sure that your knowledge base is created and is not deleted. That is, the primary key ID of the knowledge base `IndexId` is valid.
     * *   The response time may be long because this operation involves complex retrieval and matching. We recommend that you set appropriate timeout and retry policy for requests.
     * *   This interface is idempotent.
     *
     * @param tmpReq - RetrieveRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns RetrieveResponse
     */
    async retrieveWithOptions(WorkspaceId, tmpReq, headers, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new RetrieveShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.images)) {
            request.imagesShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.images, "Images", "simple");
        }
        if (!tea_util_1.default.isUnset(tmpReq.rerank)) {
            request.rerankShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.rerank, "Rerank", "json");
        }
        if (!tea_util_1.default.isUnset(tmpReq.rewrite)) {
            request.rewriteShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.rewrite, "Rewrite", "json");
        }
        if (!tea_util_1.default.isUnset(tmpReq.searchFilters)) {
            request.searchFiltersShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.searchFilters, "SearchFilters", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.denseSimilarityTopK)) {
            query["DenseSimilarityTopK"] = request.denseSimilarityTopK;
        }
        if (!tea_util_1.default.isUnset(request.enableReranking)) {
            query["EnableReranking"] = request.enableReranking;
        }
        if (!tea_util_1.default.isUnset(request.enableRewrite)) {
            query["EnableRewrite"] = request.enableRewrite;
        }
        if (!tea_util_1.default.isUnset(request.imagesShrink)) {
            query["Images"] = request.imagesShrink;
        }
        if (!tea_util_1.default.isUnset(request.indexId)) {
            query["IndexId"] = request.indexId;
        }
        if (!tea_util_1.default.isUnset(request.query)) {
            query["Query"] = request.query;
        }
        if (!tea_util_1.default.isUnset(request.rerankShrink)) {
            query["Rerank"] = request.rerankShrink;
        }
        if (!tea_util_1.default.isUnset(request.rerankMinScore)) {
            query["RerankMinScore"] = request.rerankMinScore;
        }
        if (!tea_util_1.default.isUnset(request.rerankTopN)) {
            query["RerankTopN"] = request.rerankTopN;
        }
        if (!tea_util_1.default.isUnset(request.rewriteShrink)) {
            query["Rewrite"] = request.rewriteShrink;
        }
        if (!tea_util_1.default.isUnset(request.saveRetrieverHistory)) {
            query["SaveRetrieverHistory"] = request.saveRetrieverHistory;
        }
        if (!tea_util_1.default.isUnset(request.searchFiltersShrink)) {
            query["SearchFilters"] = request.searchFiltersShrink;
        }
        if (!tea_util_1.default.isUnset(request.sparseSimilarityTopK)) {
            query["SparseSimilarityTopK"] = request.sparseSimilarityTopK;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "Retrieve",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(WorkspaceId)}/index/retrieve`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new RetrieveResponse({}));
    }
    /**
     * Queries information from a specified knowledge base.
     *
     * @remarks
     *   Before you call this operation, make sure that your knowledge base is created and is not deleted. That is, the primary key ID of the knowledge base `IndexId` is valid.
     * *   The response time may be long because this operation involves complex retrieval and matching. We recommend that you set appropriate timeout and retry policy for requests.
     * *   This interface is idempotent.
     *
     * @param request - RetrieveRequest
     * @returns RetrieveResponse
     */
    async retrieve(WorkspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.retrieveWithOptions(WorkspaceId, request, headers, runtime);
    }
    /**
     * Adds parsed documents to an unstructured knowledge base.
     *
     * @remarks
     *   You must first upload documents to [Data Management](https://bailian.console.aliyun.com/#/data-center) and obtain the `FileId`. The documents are the knowledge source of the knowledge base. For more information, see [Import Data](https://www.alibabacloud.com/help/en/model-studio/user-guide/data-import-instructions).
     * *   Before you call this operation, make sure that your knowledge base is created and is not deleted. That is, the primary key ID of the knowledge base `IndexId` is valid.
     * *   After you call this operation, you can call the [GetIndexJobStatus](https://www.alibabacloud.com/help/en/model-studio/developer-reference/api-bailian-2023-12-29-getindexjobstatus) operation to query the status of the job. More than 20 calls to the GetIndexJobStatus operation per minute may trigger throttling.
     * *   Execution takes a period of time after this operation is called. Do not make new request before the request is returned. This interface is not idempotent.
     *
     * @param tmpReq - SubmitIndexAddDocumentsJobRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns SubmitIndexAddDocumentsJobResponse
     */
    async submitIndexAddDocumentsJobWithOptions(WorkspaceId, tmpReq, headers, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new SubmitIndexAddDocumentsJobShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.categoryIds)) {
            request.categoryIdsShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.categoryIds, "CategoryIds", "json");
        }
        if (!tea_util_1.default.isUnset(tmpReq.documentIds)) {
            request.documentIdsShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.documentIds, "DocumentIds", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.categoryIdsShrink)) {
            query["CategoryIds"] = request.categoryIdsShrink;
        }
        if (!tea_util_1.default.isUnset(request.documentIdsShrink)) {
            query["DocumentIds"] = request.documentIdsShrink;
        }
        if (!tea_util_1.default.isUnset(request.indexId)) {
            query["IndexId"] = request.indexId;
        }
        if (!tea_util_1.default.isUnset(request.sourceType)) {
            query["SourceType"] = request.sourceType;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SubmitIndexAddDocumentsJob",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(WorkspaceId)}/index/add_documents_to_index`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SubmitIndexAddDocumentsJobResponse({}));
    }
    /**
     * Adds parsed documents to an unstructured knowledge base.
     *
     * @remarks
     *   You must first upload documents to [Data Management](https://bailian.console.aliyun.com/#/data-center) and obtain the `FileId`. The documents are the knowledge source of the knowledge base. For more information, see [Import Data](https://www.alibabacloud.com/help/en/model-studio/user-guide/data-import-instructions).
     * *   Before you call this operation, make sure that your knowledge base is created and is not deleted. That is, the primary key ID of the knowledge base `IndexId` is valid.
     * *   After you call this operation, you can call the [GetIndexJobStatus](https://www.alibabacloud.com/help/en/model-studio/developer-reference/api-bailian-2023-12-29-getindexjobstatus) operation to query the status of the job. More than 20 calls to the GetIndexJobStatus operation per minute may trigger throttling.
     * *   Execution takes a period of time after this operation is called. Do not make new request before the request is returned. This interface is not idempotent.
     *
     * @param request - SubmitIndexAddDocumentsJobRequest
     * @returns SubmitIndexAddDocumentsJobResponse
     */
    async submitIndexAddDocumentsJob(WorkspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.submitIndexAddDocumentsJobWithOptions(WorkspaceId, request, headers, runtime);
    }
    /**
     * Submits a specified CreateIndex job to complete knowledge base creation.
     *
     * @remarks
     * 1.  Before you call this operation, you must call the [CreateIndex](https://www.alibabacloud.com/help/en/model-studio/developer-reference/api-bailian-2023-12-29-createindex) operation and obtain the `IndexId`.
     * 2.  Execution takes a period of time after this operation is called. Do not make new request before the request is returned.
     * 3.  If you want to query the execution status of the job after you call this operation, call the [GetIndexJobStatus](https://www.alibabacloud.com/help/en/model-studio/developer-reference/api-bailian-2023-12-29-getindexjobstatus) operation.
     * 4.  This interface is not idempotent.
     *
     * @param request - SubmitIndexJobRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns SubmitIndexJobResponse
     */
    async submitIndexJobWithOptions(WorkspaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.indexId)) {
            query["IndexId"] = request.indexId;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SubmitIndexJob",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(WorkspaceId)}/index/submit_index_job`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new SubmitIndexJobResponse({}));
    }
    /**
     * Submits a specified CreateIndex job to complete knowledge base creation.
     *
     * @remarks
     * 1.  Before you call this operation, you must call the [CreateIndex](https://www.alibabacloud.com/help/en/model-studio/developer-reference/api-bailian-2023-12-29-createindex) operation and obtain the `IndexId`.
     * 2.  Execution takes a period of time after this operation is called. Do not make new request before the request is returned.
     * 3.  If you want to query the execution status of the job after you call this operation, call the [GetIndexJobStatus](https://www.alibabacloud.com/help/en/model-studio/developer-reference/api-bailian-2023-12-29-getindexjobstatus) operation.
     * 4.  This interface is not idempotent.
     *
     * @param request - SubmitIndexJobRequest
     * @returns SubmitIndexJobResponse
     */
    async submitIndexJob(WorkspaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.submitIndexJobWithOptions(WorkspaceId, request, headers, runtime);
    }
    /**
     * 
     *
     * @param tmpReq - UpdateAndPublishAgentRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateAndPublishAgentResponse
     */
    async updateAndPublishAgentWithOptions(workspaceId, appCode, tmpReq, headers, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new UpdateAndPublishAgentShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.applicationConfig)) {
            request.applicationConfigShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.applicationConfig, "applicationConfig", "json");
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.applicationConfigShrink)) {
            body["applicationConfig"] = request.applicationConfigShrink;
        }
        if (!tea_util_1.default.isUnset(request.instructions)) {
            body["instructions"] = request.instructions;
        }
        if (!tea_util_1.default.isUnset(request.modelId)) {
            body["modelId"] = request.modelId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateAndPublishAgent",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(workspaceId)}/application/agents/${openapi_util_1.default.getEncodeParam(appCode)}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateAndPublishAgentResponse({}));
    }
    /**
     * 
     *
     * @param request - UpdateAndPublishAgentRequest
     * @returns UpdateAndPublishAgentResponse
     */
    async updateAndPublishAgent(workspaceId, appCode, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.updateAndPublishAgentWithOptions(workspaceId, appCode, request, headers, runtime);
    }
    /**
     * Tag
     *
     * @param tmpReq - UpdateFileTagRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateFileTagResponse
     */
    async updateFileTagWithOptions(WorkspaceId, FileId, tmpReq, headers, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new UpdateFileTagShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.tags)) {
            request.tagsShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.tags, "Tags", "json");
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.tagsShrink)) {
            body["Tags"] = request.tagsShrink;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateFileTag",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(WorkspaceId)}/datacenter/file/${openapi_util_1.default.getEncodeParam(FileId)}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "formData",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateFileTagResponse({}));
    }
    /**
     * Tag
     *
     * @param request - UpdateFileTagRequest
     * @returns UpdateFileTagResponse
     */
    async updateFileTag(WorkspaceId, FileId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.updateFileTagWithOptions(WorkspaceId, FileId, request, headers, runtime);
    }
    /**
     * memory
     *
     * @param request - UpdateMemoryRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateMemoryResponse
     */
    async updateMemoryWithOptions(workspaceId, memoryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            query["description"] = request.description;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateMemory",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(workspaceId)}/memories/${openapi_util_1.default.getEncodeParam(memoryId)}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateMemoryResponse({}));
    }
    /**
     * memory
     *
     * @param request - UpdateMemoryRequest
     * @returns UpdateMemoryResponse
     */
    async updateMemory(workspaceId, memoryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.updateMemoryWithOptions(workspaceId, memoryId, request, headers, runtime);
    }
    /**
     * Node
     *
     * @param request - UpdateMemoryNodeRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdateMemoryNodeResponse
     */
    async updateMemoryNodeWithOptions(workspaceId, memoryId, memoryNodeId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.content)) {
            query["content"] = request.content;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdateMemoryNode",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(workspaceId)}/memories/${openapi_util_1.default.getEncodeParam(memoryId)}/memoryNodes/${openapi_util_1.default.getEncodeParam(memoryNodeId)}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdateMemoryNodeResponse({}));
    }
    /**
     * Node
     *
     * @param request - UpdateMemoryNodeRequest
     * @returns UpdateMemoryNodeResponse
     */
    async updateMemoryNode(workspaceId, memoryId, memoryNodeId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.updateMemoryNodeWithOptions(workspaceId, memoryId, memoryNodeId, request, headers, runtime);
    }
    /**
     * IdPrompt
     *
     * @param request - UpdatePromptTemplateRequest
     * @param headers - map
     * @param runtime - runtime options for this request RuntimeOptions
     * @returns UpdatePromptTemplateResponse
     */
    async updatePromptTemplateWithOptions(workspaceId, promptTemplateId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.content)) {
            query["content"] = request.content;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            query["name"] = request.name;
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UpdatePromptTemplate",
            version: "2023-12-29",
            protocol: "HTTPS",
            pathname: `/${openapi_util_1.default.getEncodeParam(workspaceId)}/promptTemplates/${openapi_util_1.default.getEncodeParam(promptTemplateId)}`,
            method: "PATCH",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.callApi(params, req, runtime), new UpdatePromptTemplateResponse({}));
    }
    /**
     * IdPrompt
     *
     * @param request - UpdatePromptTemplateRequest
     * @returns UpdatePromptTemplateResponse
     */
    async updatePromptTemplate(workspaceId, promptTemplateId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.updatePromptTemplateWithOptions(workspaceId, promptTemplateId, request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map